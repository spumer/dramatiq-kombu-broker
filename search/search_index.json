{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Dramatiq Kombu Broker","text":"<p>A Kombu-based broker for Dramatiq with connection pooling and better RabbitMQ integration.</p>"},{"location":"#what-this-does","title":"What This Does","text":"<p><code>dramatiq-kombu-broker</code> replaces Dramatiq's standard RabbitMQ broker with one built on Kombu. The main benefits:</p> <p>Connection pooling - The standard broker creates many connections that can overwhelm RabbitMQ. This broker pools connections properly.</p> <p>Channel pooling - Via kombu-pyamqp-threadsafe, you won't hit \"Connection limit reached\" errors in threaded applications.</p> <p>Topology management - Change queue configurations without breaking your existing setup. The broker handles topology mismatches gracefully.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install dramatiq-kombu-broker\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker\nimport dramatiq\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://guest:guest@localhost:5672/\"\n    }\n)\ndramatiq.set_broker(broker)\n\n@dramatiq.actor\ndef process_task(task_id: int):\n    print(f\"Processing task {task_id}\")\n\nprocess_task.send(42)\n</code></pre>"},{"location":"#other-features","title":"Other Features","text":"<ul> <li>Hostname automatically added to connection properties (visible in RabbitMQ management UI)</li> <li>Change default queue name without modifying all actors</li> <li>Built-in consumer healthchecks</li> <li>Message acknowledgment tracking (<code>Message.acknowledged</code>)</li> <li>No Pika dependency (cleaner logs)</li> <li>Memory protection for delayed messages - Configure <code>max_delay_time</code> to prevent RabbitMQ memory exhaustion from long-lived delayed messages</li> <li>Deadlock protection - <code>confirm_timeout</code> prevents infinite blocking when connection fails during publish confirmation</li> </ul>"},{"location":"#when-to-use-this","title":"When To Use This","text":"<p>Use this broker if you're:</p> <ul> <li>Running into connection limit issues</li> <li>Using threaded workers or applications</li> <li>Need reliable delayed message delivery</li> <li>Want better visibility into your connections</li> <li>Migrating from standard broker and hitting topology errors</li> </ul> <p>Stick with the standard broker if you're:</p> <ul> <li>Just starting with Dramatiq (use standard until you hit limits)</li> <li>Running a single-threaded worker with low traffic</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation</li> <li>Quick Start</li> <li>Configuration</li> <li>Topologies</li> <li>Examples</li> <li>Migration Guide</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>Report bugs: GitHub Issues</li> <li>Ask questions: GitHub Discussions</li> </ul>"},{"location":"alternatives/","title":"Alternatives Comparison","text":"<p>How dramatiq-kombu-broker compares to other solutions for RabbitMQ connection management.</p>"},{"location":"alternatives/#overview","title":"Overview","text":"<p>Different tools solve different problems:</p> <ul> <li>dramatiq-kombu-broker - Dramatiq broker with built-in pooling</li> <li>AMQProxy - Standalone proxy for connection pooling</li> <li>AMQPStorm - Low-level AMQP client library</li> </ul>"},{"location":"alternatives/#dramatiq-kombu-broker-vs-amqproxy","title":"dramatiq-kombu-broker vs AMQProxy","text":""},{"location":"alternatives/#what-is-amqproxy","title":"What is AMQProxy?","text":"<p>AMQProxy is a standalone proxy that sits between your application and RabbitMQ. It pools connections and channels, so short-lived applications (like PHP scripts) don't create connection churn.</p> <p>Architecture: <pre><code>App \u2192 AMQProxy (localhost:5673) \u2192 RabbitMQ (host:5672)\n</code></pre></p>"},{"location":"alternatives/#key-differences","title":"Key Differences","text":"Aspect dramatiq-kombu-broker AMQProxy Type Python library Standalone proxy Deployment In-process Separate service Language Python Crystal Scope Dramatiq only Any AMQP client Pooling Native Python Proxy-level Latency Direct connection Extra proxy hop Maintenance Python package Additional service"},{"location":"alternatives/#when-to-use-amqproxy","title":"When to Use AMQProxy","text":"<p>Use AMQProxy if:</p> <ul> <li>You have PHP or other short-lived applications</li> <li>Multiple languages connect to same RabbitMQ</li> <li>Cannot modify application code</li> <li>Need cross-platform solution (works with any AMQP 0.9.1 client)</li> <li>Publishing 1 message per connection (50x throughput improvement)</li> </ul> <p>Example: PHP application that opens connection per request: <pre><code>// Without AMQProxy: opens new connection each time (slow)\n$connection = new AMQPConnection(['host' =&gt; 'rabbitmq']);\n\n// With AMQProxy: connection reused (fast)\n$connection = new AMQPConnection(['host' =&gt; 'amqproxy', 'port' =&gt; 5673]);\n</code></pre></p>"},{"location":"alternatives/#when-to-use-dramatiq-kombu-broker","title":"When to Use dramatiq-kombu-broker","text":"<p>Use dramatiq-kombu-broker if:</p> <ul> <li>You're using Python and Dramatiq</li> <li>Want native integration without external services</li> <li>Need custom topology control</li> <li>Running long-lived Python workers</li> <li>Prefer fewer moving parts in infrastructure</li> </ul>"},{"location":"alternatives/#can-you-use-both","title":"Can You Use Both?","text":"<p>Yes, but typically unnecessary:</p> <pre><code># dramatiq-kombu-broker connecting through AMQProxy\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://localhost:5673/\"  # AMQProxy address\n    }\n)\n</code></pre> <p>This adds an extra hop with minimal benefit for Python applications.</p>"},{"location":"alternatives/#performance-comparison","title":"Performance Comparison","text":"<p>AMQProxy (source): - Publishing 1 message per connection (with TLS, 50ms RTT):   - Without proxy: 0.50s per message   - With proxy: 0.01s per message (50x faster!)</p> <p>dramatiq-kombu-broker: - Keeps connections open between messages - No per-message connection overhead - Similar performance to AMQProxy for Python apps</p>"},{"location":"alternatives/#dramatiq-kombu-broker-vs-amqpstorm","title":"dramatiq-kombu-broker vs AMQPStorm","text":""},{"location":"alternatives/#what-is-amqpstorm","title":"What is AMQPStorm?","text":"<p>AMQPStorm is a thread-safe Python AMQP 0.9.1 client library. It's a low-level library for working with RabbitMQ directly.</p>"},{"location":"alternatives/#key-differences_1","title":"Key Differences","text":"Aspect dramatiq-kombu-broker AMQPStorm Level High-level (Dramatiq broker) Low-level (AMQP client) Task Queue Built-in (Dramatiq) Not included Connection Management Automatic Manual Threading Thread-safe channels Thread-safe connections Retries Dramatiq handles Manual implementation API Dramatiq actors Direct AMQP operations"},{"location":"alternatives/#when-to-use-amqpstorm","title":"When to Use AMQPStorm","text":"<p>Use AMQPStorm if:</p> <ul> <li>Building custom message patterns (not task queue)</li> <li>Need low-level AMQP control</li> <li>Want minimal dependencies</li> <li>Implementing your own task queue</li> <li>Not using Dramatiq at all</li> </ul> <p>Example AMQPStorm usage: <pre><code>import amqpstorm\n\n# Direct AMQP operations\nconnection = amqpstorm.Connection('localhost', 'guest', 'guest')\nchannel = connection.channel()\nchannel.queue.declare('my_queue')\nchannel.basic.publish('Hello', 'my_queue')\n</code></pre></p>"},{"location":"alternatives/#when-to-use-dramatiq-kombu-broker_1","title":"When to Use dramatiq-kombu-broker","text":"<p>Use dramatiq-kombu-broker if:</p> <ul> <li>You're using Dramatiq for task queue</li> <li>Want high-level abstractions (actors, retries, etc.)</li> <li>Need production-ready task processing</li> <li>Prefer less boilerplate code</li> </ul> <p>Example dramatiq-kombu-broker: <pre><code>import dramatiq\nfrom dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://localhost\"}\n)\ndramatiq.set_broker(broker)\n\n@dramatiq.actor\ndef send_email(email):\n    # Automatically handles: retries, delays, priorities, etc.\n    pass\n\nsend_email.send(\"user@example.com\")\n</code></pre></p>"},{"location":"alternatives/#could-you-build-dramatiq-kombu-broker-on-amqpstorm","title":"Could You Build dramatiq-kombu-broker on AMQPStorm?","text":"<p>Theoretically yes, but Kombu already provides:</p> <ul> <li>Battle-tested AMQP abstraction</li> <li>Works with multiple brokers (RabbitMQ, Redis, etc.)</li> <li>Large ecosystem and community</li> <li>Thread-safe channel pooling (via kombu-pyamqp-threadsafe)</li> </ul>"},{"location":"alternatives/#comparison-matrix","title":"Comparison Matrix","text":"Feature dramatiq-kombu-broker AMQProxy AMQPStorm Primary Use Case Dramatiq task queue Cross-language pooling Custom AMQP apps Connection Pooling \u2705 Yes \u2705 Yes \u274c Manual Channel Pooling \u2705 Yes \u2705 Yes \u274c Manual Language Python Any AMQP client Python Deployment Library Standalone service Library Task Queue \u2705 Dramatiq \u274c No \u274c No Thread Safety \u2705 Yes \u2705 Yes \u2705 Yes Learning Curve Low (if using Dramatiq) Low Medium-High Latency Direct +1 hop Direct Management API Via Kombu \u274c No \u2705 Yes SSL/TLS \u2705 Yes \u2705 Yes \u2705 Yes"},{"location":"alternatives/#real-world-scenarios","title":"Real-World Scenarios","text":""},{"location":"alternatives/#scenario-1-php-python-mixed","title":"Scenario 1: PHP + Python Mixed","text":"<p>Setup: PHP web app + Python workers</p> <p>Solution: AMQProxy</p> <ul> <li>PHP publishes via AMQProxy (pools connections)</li> <li>Python workers consume directly or via AMQProxy</li> <li>Single pooling solution for all languages</li> </ul>"},{"location":"alternatives/#scenario-2-pure-python-task-queue","title":"Scenario 2: Pure Python Task Queue","text":"<p>Setup: Django/Flask + Dramatiq workers</p> <p>Solution: dramatiq-kombu-broker</p> <ul> <li>No external services needed</li> <li>Native Dramatiq integration</li> <li>Fewer moving parts</li> </ul>"},{"location":"alternatives/#scenario-3-custom-message-broker","title":"Scenario 3: Custom Message Broker","text":"<p>Setup: Building your own pub/sub system</p> <p>Solution: AMQPStorm</p> <ul> <li>Full AMQP control</li> <li>Implement custom patterns</li> <li>Direct access to protocol features</li> </ul>"},{"location":"alternatives/#scenario-4-short-lived-scripts","title":"Scenario 4: Short-Lived Scripts","text":"<p>Setup: Cron jobs publishing to RabbitMQ</p> <p>Solution: AMQProxy or dramatiq-kombu-broker</p> <ul> <li>AMQProxy: If scripts in different languages</li> <li>dramatiq-kombu-broker: If all Python scripts</li> </ul>"},{"location":"alternatives/#migration-paths","title":"Migration Paths","text":""},{"location":"alternatives/#from-standard-dramatiq-dramatiq-kombu-broker","title":"From Standard Dramatiq \u2192 dramatiq-kombu-broker","text":"<p>Simple drop-in replacement. See Migration Guide.</p>"},{"location":"alternatives/#from-amqproxy-dramatiq-kombu-broker","title":"From AMQProxy \u2192 dramatiq-kombu-broker","text":"<pre><code># Before: connecting through AMQProxy\nRABBITMQ_URL = \"amqp://localhost:5673/\"\n\n# After: direct connection with pooling\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://rabbitmq:5672/\"  # Direct to RabbitMQ\n    }\n)\n</code></pre> <p>Then stop AMQProxy service.</p>"},{"location":"alternatives/#from-amqpstorm-dramatiq-kombu-broker","title":"From AMQPStorm \u2192 dramatiq-kombu-broker","text":"<p>Requires rewriting code to use Dramatiq actors instead of direct AMQP calls. Worth it if you want task queue features.</p>"},{"location":"alternatives/#when-to-use-each","title":"When to Use Each","text":"<p>Use dramatiq-kombu-broker when: - Python + Dramatiq task queue - Want integrated solution - Need topology control - Long-lived workers</p> <p>Use AMQProxy when: - Multiple languages - Short-lived connections (PHP, etc.) - Cannot change application code - Need universal solution</p> <p>Use AMQPStorm when: - Building custom AMQP application - Need low-level control - Not using task queue - Implementing custom patterns</p>"},{"location":"alternatives/#sources","title":"Sources","text":"<ul> <li>AMQProxy GitHub</li> <li>AMQProxy Blog Post</li> <li>AMQPStorm GitHub</li> <li>AMQPStorm Documentation</li> </ul>"},{"location":"alternatives/#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Get started with dramatiq-kombu-broker</li> <li>Configuration - Configure connection pooling</li> <li>Migration Guide - Migrate from other solutions</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API documentation for dramatiq-kombu-broker.</p>"},{"location":"api-reference/#broker-classes","title":"Broker Classes","text":""},{"location":"api-reference/#connectionpooledkombubroker","title":"ConnectionPooledKombuBroker","text":"<pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    middleware=None,\n    default_queue_name=\"default\",\n    blocking_acknowledge=True,\n    connection_holder_options=None,\n    kombu_connection_options={},\n    confirm_delivery=True,\n    max_priority=None,\n    max_enqueue_attempts=None,\n    max_declare_attempts=None,\n    max_producer_acquire_timeout=10.0,\n    confirm_timeout=5.0,\n    topology=None,\n)\n</code></pre> <p>Parameters: - <code>middleware</code> - List of middleware instances - <code>default_queue_name</code> - Default queue name (default: <code>\"default\"</code>) - <code>blocking_acknowledge</code> - Block on message acknowledgment (default: <code>True</code>) - <code>connection_holder_options</code> - Dict with <code>max_connections</code> key - <code>kombu_connection_options</code> - Connection parameters (see below) - <code>confirm_delivery</code> - Wait for broker confirmation (default: <code>True</code>) - <code>max_priority</code> - Max priority value for priority queues - <code>max_enqueue_attempts</code> - Retry count for enqueue operations - <code>max_declare_attempts</code> - Retry count for queue declarations - <code>max_producer_acquire_timeout</code> - Timeout for acquiring producer (seconds) - <code>confirm_timeout</code> - Timeout for RabbitMQ publish confirmation (default: <code>5.0</code> seconds) - <code>topology</code> - Custom topology instance</p>"},{"location":"api-reference/#connectionsharedkombubroker","title":"ConnectionSharedKombuBroker","text":"<p>Same parameters as <code>ConnectionPooledKombuBroker</code>, but <code>connection_holder_options</code> accepts:</p> <pre><code>connection_holder_options={\n    \"consumer_channel_pool_size\": 5  # Channel pool size\n}\n</code></pre>"},{"location":"api-reference/#kombu-connection-options","title":"Kombu Connection Options","text":"<pre><code>kombu_connection_options = {\n    # Connection\n    \"hostname\": \"amqp://user:pass@host:5672/vhost\",  # Or separate params:\n    \"hostname\": \"localhost\",\n    \"port\": 5672,\n    \"userid\": \"guest\",\n    \"password\": \"guest\",\n    \"virtual_host\": \"/\",\n\n    # SSL/TLS\n    \"ssl\": False,\n    \"ssl_options\": {\n        \"ca_certs\": \"/path/to/ca.pem\",\n        \"certfile\": \"/path/to/cert.pem\",\n        \"keyfile\": \"/path/to/key.pem\",\n    },\n\n    # Timeouts\n    \"heartbeat\": 60,  # Default value\n    \"connect_timeout\": 10,\n\n    # Transport options\n    \"transport_options\": {\n        \"max_retries\": 3,\n        \"interval_start\": 0,\n        \"interval_step\": 2,\n        \"interval_max\": 30,\n        \"confirm_publish\": True,\n        \"client_properties\": {\n            \"connection_name\": \"my-app\",\n        },\n    },\n}\n</code></pre>"},{"location":"api-reference/#topology-classes","title":"Topology Classes","text":""},{"location":"api-reference/#defaultdramatiqtopology","title":"DefaultDramatiqTopology","text":"<pre><code>from dramatiq_kombu_broker import DefaultDramatiqTopology\n\ntopology = DefaultDramatiqTopology(\n    logger=None,\n    dlx_exchange_name=\"\",\n    durable=True,\n    auto_delete=False,\n    max_priority=None,\n    dead_letter_message_ttl=timedelta(days=7),\n)\n</code></pre> <p>Methods: - <code>get_canonical_queue_name(queue_name)</code> - Returns main queue name - <code>get_delay_queue_name(queue_name)</code> - Returns delay queue name - <code>get_dead_letter_queue_name(queue_name)</code> - Returns DLQ name - <code>get_queue_name_tuple(queue_name)</code> - Returns <code>QueueName(canonical, delayed, dead_letter)</code></p>"},{"location":"api-reference/#dlxroutingtopology","title":"DLXRoutingTopology","text":"<pre><code>from dramatiq_kombu_broker import DLXRoutingTopology\nimport datetime as dt\n\ntopology = DLXRoutingTopology(\n    max_delay_time=dt.timedelta(hours=24),\n    dead_letter_message_ttl=None,\n    # ... plus all DefaultDramatiqTopology parameters\n)\n</code></pre> <p>Routes delay queue \u2192 DLX \u2192 canonical queue.</p>"},{"location":"api-reference/#broker-methods","title":"Broker Methods","text":""},{"location":"api-reference/#declare_queue","title":"declare_queue","text":"<pre><code>broker.declare_queue(queue_name, ensure=False)\n</code></pre> <p>Declare a queue. If <code>ensure=True</code>, creates queues immediately.</p>"},{"location":"api-reference/#get_queue_message_counts","title":"get_queue_message_counts","text":"<pre><code>main, delay, dlq = broker.get_queue_message_counts(\"myqueue\")\n</code></pre> <p>Returns tuple of message counts in (main, delay, dead_letter) queues.</p>"},{"location":"api-reference/#flush","title":"flush","text":"<pre><code>broker.flush(\"myqueue\")  # Clear all messages\n</code></pre>"},{"location":"api-reference/#flush_all","title":"flush_all","text":"<pre><code>broker.flush_all()  # Clear all queues\n</code></pre>"},{"location":"api-reference/#delete_queue","title":"delete_queue","text":"<pre><code>broker.delete_queue(\"myqueue\")\n</code></pre> <p>Delete queue and associated delay/DLQ queues.</p>"},{"location":"api-reference/#close","title":"close","text":"<pre><code>broker.close()\n</code></pre> <p>Close all connections.</p>"},{"location":"api-reference/#testing-utilities","title":"Testing Utilities","text":""},{"location":"api-reference/#ensure_consumer_connection_rabbitmq","title":"ensure_consumer_connection_rabbitmq","text":"<pre><code>from dramatiq_kombu_broker.testing import ensure_consumer_connection_rabbitmq\n\ntry:\n    ensure_consumer_connection_rabbitmq(broker)\n    print(\"Connection healthy\")\nexcept Exception as e:\n    print(f\"Connection failed: {e}\")\n</code></pre> <p>Tests broker connection health.</p>"},{"location":"api-reference/#type-definitions","title":"Type Definitions","text":""},{"location":"api-reference/#queuename","title":"QueueName","text":"<pre><code>from dramatiq_kombu_broker.topology import QueueName\n\nnames = QueueName(\n    canonical=\"myqueue\",\n    delayed=\"myqueue.DQ\",\n    dead_letter=\"myqueue.XQ\"\n)\n\nprint(names.canonical)  # \"myqueue\"\nprint(names.delayed)    # \"myqueue.DQ\"\nprint(names.dead_letter)  # \"myqueue.XQ\"\n</code></pre>"},{"location":"api-reference/#kombuconnectionoptions","title":"KombuConnectionOptions","text":"<pre><code>from dramatiq_kombu_broker import KombuConnectionOptions\n\noptions: KombuConnectionOptions = {\n    \"hostname\": \"localhost\",\n    \"port\": 5672,\n    # ... other connection params\n}\n</code></pre>"},{"location":"api-reference/#kombutransportoptions","title":"KombuTransportOptions","text":"<pre><code>from dramatiq_kombu_broker import KombuTransportOptions\n\ntransport_options: KombuTransportOptions = {\n    \"max_retries\": 3,\n    \"interval_start\": 0,\n    # ... other transport params\n}\n</code></pre>"},{"location":"api-reference/#exports","title":"Exports","text":"<p>Module <code>dramatiq_kombu_broker</code> exports:</p> <pre><code>from dramatiq_kombu_broker import (\n    # Brokers\n    KombuBroker,\n    ConnectionPooledKombuBroker,\n    ConnectionSharedKombuBroker,\n\n    # Topologies\n    DefaultDramatiqTopology,\n    DLXRoutingTopology,\n\n    # Types\n    KombuConnectionOptions,\n    KombuTransportOptions,\n    MessageProxy,\n)\n</code></pre>"},{"location":"api-reference/#environment-variables","title":"Environment Variables","text":""},{"location":"api-reference/#dramatiq_dead_message_ttl","title":"DRAMATIQ_DEAD_MESSAGE_TTL","text":"<p>TTL for dead letter queue messages (milliseconds):</p> <pre><code>export DRAMATIQ_DEAD_MESSAGE_TTL=604800000  # 7 days\n</code></pre>"},{"location":"api-reference/#django-integration","title":"Django Integration","text":""},{"location":"api-reference/#settings","title":"Settings","text":"<pre><code># settings.py\nDRAMATIQ_BROKER = {\n    \"BROKER\": \"dramatiq_kombu_broker.broker.ConnectionSharedKombuBroker\",\n    \"OPTIONS\": {\n        \"kombu_connection_options\": {...},\n        \"connection_holder_options\": {...},\n        # ... other broker options\n    },\n}\n</code></pre>"},{"location":"api-reference/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - See API usage examples</li> <li>Configuration - Detailed configuration guide</li> <li>Topologies - Queue topology configuration</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project are documented in CHANGELOG.md in the repository.</p>"},{"location":"changelog/#recent-changes","title":"Recent Changes","text":"<p>For the most up-to-date changelog, see:</p> <p>https://github.com/spumer/dramatiq-kombu-broker/blob/main/CHANGELOG.md</p>"},{"location":"changelog/#versioning","title":"Versioning","text":"<p>This project follows Semantic Versioning:</p> <ul> <li>MAJOR version for incompatible API changes</li> <li>MINOR version for new functionality in a backward compatible manner</li> <li>PATCH version for backward compatible bug fixes</li> </ul>"},{"location":"changelog/#release-history","title":"Release History","text":"<p>See GitHub Releases for release notes and download links.</p>"},{"location":"changelog/#contributing","title":"Contributing","text":"<p>Changes are tracked using Conventional Commits and automated with Commitizen.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Complete reference for configuring dramatiq-kombu-broker.</p>"},{"location":"configuration/#broker-types","title":"Broker Types","text":"<p>dramatiq-kombu-broker provides three broker implementations:</p>"},{"location":"configuration/#connectionpooledkombubroker","title":"ConnectionPooledKombuBroker","text":"<p>Uses a connection pool for multiple connections to RabbitMQ.</p> <p>Best for: High-throughput applications, multiple workers</p> <pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    connection_holder_options={\n        \"max_connections\": 10,\n    },\n)\n</code></pre>"},{"location":"configuration/#connectionsharedkombubroker","title":"ConnectionSharedKombuBroker","text":"<p>Uses a single shared connection with channel pooling.</p> <p>Best for: Thread-heavy applications, Django applications</p> <pre><code>from dramatiq_kombu_broker import ConnectionSharedKombuBroker\n\nbroker = ConnectionSharedKombuBroker(\n    kombu_connection_options={...},\n    connection_holder_options={\n        \"consumer_channel_pool_size\": 5,\n    },\n)\n</code></pre>"},{"location":"configuration/#kombubroker","title":"KombuBroker","text":"<p>Base broker class. Use specific implementations above.</p>"},{"location":"configuration/#connection-options","title":"Connection Options","text":""},{"location":"configuration/#kombu_connection_options","title":"kombu_connection_options","text":"<p>Dictionary with connection parameters:</p> <pre><code>kombu_connection_options = {\n    # Connection URL (alternative to individual params)\n    \"hostname\": \"amqp://user:pass@localhost:5672/vhost\",\n\n    # Or individual parameters:\n    \"hostname\": \"localhost\",\n    \"port\": 5672,\n    \"userid\": \"guest\",\n    \"password\": \"guest\",\n    \"virtual_host\": \"/\",\n\n    # SSL/TLS\n    \"ssl\": True,\n    \"ssl_options\": {\n        \"ca_certs\": \"/path/to/ca.pem\",\n        \"certfile\": \"/path/to/cert.pem\",\n        \"keyfile\": \"/path/to/key.pem\",\n    },\n\n    # Timeouts\n    \"heartbeat\": 60,  # Heartbeat interval in seconds (default: 60)\n    \"connect_timeout\": 10,  # Connection timeout\n\n    # Transport options\n    \"transport_options\": {\n        \"max_retries\": 3,\n        \"interval_start\": 0,\n        \"interval_step\": 2,\n        \"interval_max\": 30,\n        \"confirm_publish\": True,\n    },\n}\n</code></pre>"},{"location":"configuration/#connection-url-format","title":"Connection URL Format","text":"<pre><code>amqp://username:password@hostname:port/virtual_host\n</code></pre> <p>Examples:</p> <pre><code># Local development\n\"hostname\": \"amqp://guest:guest@localhost:5672/\"\n\n# Production with SSL\n\"hostname\": \"amqps://user:pass@prod.rabbitmq.com:5671/production\"\n\n# With query parameters\n\"hostname\": \"amqp://user:pass@host:5672/?heartbeat=60\"\n</code></pre>"},{"location":"configuration/#broker-parameters","title":"Broker Parameters","text":""},{"location":"configuration/#default_queue_name","title":"default_queue_name","text":"<p>Change the default queue name (default: <code>\"default\"</code>):</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    default_queue_name=\"myapp\",  # Instead of \"default\"\n)\n</code></pre> <p>How it works:</p> <p>When an actor is declared, the broker checks if its <code>queue_name</code> equals <code>\"default\"</code>. If so, it automatically replaces it with the configured <code>default_queue_name</code>. This happens at actor declaration time, so no code changes are needed in your actors.</p> <p>When replacement happens:</p> Actor Definition default_queue_name Resulting Queue <code>@dramatiq.actor</code> <code>\"myapp\"</code> <code>\"myapp\"</code> <code>@dramatiq.actor(queue_name=\"default\")</code> <code>\"myapp\"</code> <code>\"myapp\"</code> <code>@dramatiq.actor(queue_name=\"critical\")</code> <code>\"myapp\"</code> <code>\"critical\"</code> <p>Example:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    default_queue_name=\"myapp\",\n)\ndramatiq.set_broker(broker)\n\n# This actor uses \"default\" queue by default\n# It will be automatically changed to \"myapp\"\n@dramatiq.actor\ndef send_email(to: str, subject: str):\n    pass\n\n# This actor explicitly uses \"critical\" queue\n# It will NOT be changed (keeps \"critical\")\n@dramatiq.actor(queue_name=\"critical\")\ndef urgent_notification(message: str):\n    pass\n</code></pre> <p>Use cases:</p> <ul> <li>Migration: Replace queue names when migrating from another broker without touching actor code</li> <li>Multi-tenant: Run separate instances with different queue prefixes</li> <li>Namespacing: Prefix queues with application name to avoid conflicts in shared RabbitMQ</li> </ul>"},{"location":"configuration/#blocking_acknowledge","title":"blocking_acknowledge","text":"<p>Whether to block when acknowledging messages (default: <code>True</code>):</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    blocking_acknowledge=True,  # Wait for ACK confirmation\n)\n</code></pre> <p>When <code>True</code>, worker waits for RabbitMQ to confirm that the message was acknowledged before processing the next message. This provides stronger delivery guarantees but slightly lower throughput.</p> <p>See Delivery Guarantees for detailed explanation and best practices.</p>"},{"location":"configuration/#confirm_delivery","title":"confirm_delivery","text":"<p>Confirm message delivery with RabbitMQ (default: <code>True</code>):</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    confirm_delivery=True,  # Ensures messages are persisted\n)\n</code></pre> <p>When <code>True</code>, RabbitMQ confirms that published messages were received and routed to queues. This uses RabbitMQ Publisher Confirms mechanism.</p> <p>See Delivery Guarantees for detailed explanation and best practices.</p>"},{"location":"configuration/#max_priority","title":"max_priority","text":"<p>Enable priority queues with maximum priority value:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    max_priority=10,  # Priorities 0-10\n)\n\n# Usage:\n@dramatiq.actor\ndef my_task():\n    pass\n\nmy_task.send_with_options(args=(), broker_priority=10)  # High priority\n</code></pre>"},{"location":"configuration/#max_enqueue_attempts","title":"max_enqueue_attempts","text":"<p>Maximum retries when enqueuing messages (default: <code>None</code> - unlimited):</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    max_enqueue_attempts=3,\n)\n</code></pre>"},{"location":"configuration/#max_declare_attempts","title":"max_declare_attempts","text":"<p>Maximum retries when declaring queues (default: <code>None</code> - unlimited):</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    max_declare_attempts=5,\n)\n</code></pre>"},{"location":"configuration/#max_producer_acquire_timeout","title":"max_producer_acquire_timeout","text":"<p>Timeout for acquiring a producer from the pool (default: 10 seconds):</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    max_producer_acquire_timeout=30.0,  # 30 seconds\n)\n</code></pre>"},{"location":"configuration/#confirm_timeout","title":"confirm_timeout","text":"<p>Timeout for waiting RabbitMQ publish confirmation (default: <code>5.0</code> seconds):</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    confirm_timeout=5.0,  # Default: 5 seconds\n)\n</code></pre> <p>When <code>confirm_delivery=True</code>, the broker waits for RabbitMQ to confirm that the message was received. Without a timeout, this wait can block indefinitely if the connection drops during publishing, causing a deadlock.</p> <p>Why this matters:</p> <ul> <li>Prevents worker threads from hanging forever on connection failures</li> <li>Works in conjunction with <code>heartbeat=60</code> (different protection levels)</li> <li><code>heartbeat</code> detects dead connections at the transport level</li> <li><code>confirm_timeout</code> prevents blocking at the application level during publish</li> </ul> <p>Recommended values:</p> Scenario confirm_timeout Notes Production (default) <code>5.0</code> Good balance of safety and responsiveness High-latency networks <code>10.0</code> - <code>30.0</code> Allow more time for slow confirmations Local development <code>5.0</code> Default is usually sufficient Disable timeout <code>None</code> Not recommended - can cause deadlocks <p>Relationship with other parameters:</p> <ul> <li><code>confirm_delivery=True</code> - Required for <code>confirm_timeout</code> to have effect</li> <li><code>heartbeat=60</code> - Detects dead connections (complementary protection)</li> <li><code>max_producer_acquire_timeout</code> - Timeout for getting producer from pool (different stage)</li> </ul> <p>See Delivery Guarantees for detailed explanation.</p>"},{"location":"configuration/#topology","title":"topology","text":"<p>Custom topology for queue routing (see Topologies):</p> <pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker, DLXRoutingTopology\nimport datetime as dt\n\ntopology = DLXRoutingTopology(\n    delay_queue_ttl=dt.timedelta(hours=3),\n)\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    topology=topology,  # Use custom topology\n)\n</code></pre>"},{"location":"configuration/#connection-holder-options","title":"Connection Holder Options","text":""},{"location":"configuration/#for-connectionpooledkombubroker","title":"For ConnectionPooledKombuBroker","text":"<pre><code>connection_holder_options = {\n    \"max_connections\": 10,  # Pool size\n}\n</code></pre>"},{"location":"configuration/#for-connectionsharedkombubroker","title":"For ConnectionSharedKombuBroker","text":"<pre><code>connection_holder_options = {\n    \"consumer_channel_pool_size\": 5,  # Channel pool size\n}\n</code></pre>"},{"location":"configuration/#complete-example","title":"Complete Example","text":"<pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker\nimport dramatiq\n\nbroker = ConnectionPooledKombuBroker(\n    # Connection settings\n    kombu_connection_options={\n        \"hostname\": \"amqp://myapp:secret@rabbitmq.prod:5672/production\",\n        \"heartbeat\": 60,\n        \"ssl\": True,\n        \"ssl_options\": {\n            \"ca_certs\": \"/etc/ssl/certs/ca.pem\",\n        },\n        \"transport_options\": {\n            \"max_retries\": 3,\n            \"confirm_publish\": True,\n        },\n    },\n\n    # Pool settings\n    connection_holder_options={\n        \"max_connections\": 20,\n    },\n\n    # Broker settings\n    default_queue_name=\"myapp\",\n    max_priority=10,\n    confirm_delivery=True,\n    confirm_timeout=5.0,  # Deadlock protection\n    blocking_acknowledge=True,\n    max_enqueue_attempts=3,\n    max_declare_attempts=5,\n    max_producer_acquire_timeout=30.0,\n)\n\ndramatiq.set_broker(broker)\n</code></pre>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>You can use environment variables for configuration:</p> <pre><code>import os\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": os.environ[\"RABBITMQ_URL\"],\n    },\n    max_priority=int(os.environ.get(\"RABBITMQ_MAX_PRIORITY\", \"10\")),\n)\n</code></pre> <p>Example <code>.env</code> file:</p> <pre><code>RABBITMQ_URL=amqp://guest:guest@localhost:5672/\nRABBITMQ_MAX_PRIORITY=10\n</code></pre>"},{"location":"configuration/#django-settings","title":"Django Settings","text":"<p>For Django applications with django-dramatiq:</p> <pre><code># settings.py\nimport os\n\nDRAMATIQ_BROKER = {\n    \"BROKER\": \"dramatiq_kombu_broker.broker.ConnectionSharedKombuBroker\",\n    \"OPTIONS\": {\n        \"kombu_connection_options\": {\n            \"hostname\": os.environ[\"RABBITMQ_URL\"],\n            \"heartbeat\": 60,\n        },\n        \"connection_holder_options\": {\n            \"consumer_channel_pool_size\": 5,\n        },\n        \"default_queue_name\": \"django_app\",\n        \"max_priority\": 10,\n        \"confirm_delivery\": True,\n    },\n}\n</code></pre>"},{"location":"configuration/#testing-configuration","title":"Testing Configuration","text":"<p>For tests, use a separate RabbitMQ instance or vhost:</p> <pre><code># conftest.py\nimport pytest\nfrom dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\n@pytest.fixture\ndef broker():\n    broker = ConnectionPooledKombuBroker(\n        kombu_connection_options={\n            \"hostname\": \"amqp://guest:guest@localhost:5672/test\",  # /test vhost\n        },\n    )\n    yield broker\n    broker.flush_all()  # Clean up after tests\n    broker.close()\n</code></pre>"},{"location":"configuration/#production-checklist","title":"Production Checklist","text":"<ul> <li>\u2705 Use SSL/TLS for production connections</li> <li>\u2705 Enable <code>confirm_delivery</code> for reliability</li> <li>\u2705 Set <code>confirm_timeout</code> for deadlock protection (default: 5.0s is usually sufficient)</li> <li>\u2705 Heartbeat set to 60s by default - adjust for unreliable networks if needed</li> <li>\u2705 Configure connection pooling based on workload</li> <li>\u2705 Set <code>max_priority</code> if using priority queues</li> <li>\u2705 Use separate vhosts for different environments</li> <li>\u2705 Monitor connection count in RabbitMQ management UI</li> <li>\u2705 Set <code>max_enqueue_attempts</code> and <code>max_declare_attempts</code> for resilience</li> <li>\u2705 Configure proper retry policies in transport_options</li> </ul>"},{"location":"configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Topologies - Learn about queue routing</li> <li>Performance Tuning - Optimize for your workload</li> <li>Examples - See real-world configurations</li> </ul>"},{"location":"connections/","title":"Connection Management","text":"<p>Operational guide for managing RabbitMQ connections: how connections are created, monitored, troubleshooted, and maintained at runtime.</p> <p>For configuration parameters, see Configuration.</p>"},{"location":"connections/#broker-types","title":"Broker Types","text":"<p>dramatiq-kombu-broker provides two connection strategies:</p> <ul> <li>ConnectionPooledKombuBroker: Multiple connections, each reused for operations</li> <li>ConnectionSharedKombuBroker: Single shared connection with channel pooling</li> </ul> <p>See Configuration - Broker Types for detailed parameters and usage examples.</p>"},{"location":"connections/#connection-lifecycle","title":"Connection Lifecycle","text":"<ol> <li>Broker creates connection holder on init</li> <li>Connection holder manages connections/channels</li> <li>Operations acquire connection/channel from pool</li> <li>After use, connection/channel returns to pool</li> <li>On broker close, all connections are closed</li> </ol>"},{"location":"connections/#heartbeats","title":"Heartbeats","text":"<p>Heartbeats keep connections alive and detect dead connections. By default, heartbeat is set to 60 seconds - no configuration needed for most use cases.</p> <p>To override the default heartbeat interval:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://...\",\n        \"heartbeat\": 30,  # Override: reduce for unreliable networks\n    },\n)\n</code></pre> <p>If network is unreliable, reduce heartbeat interval (e.g., 30 seconds).</p>"},{"location":"connections/#connection-retries","title":"Connection Retries","text":"<p>Configure retry behavior:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://...\",\n        \"transport_options\": {\n            \"max_retries\": 3,  # Retry 3 times\n            \"interval_start\": 0,  # Start immediately\n            \"interval_step\": 2,  # Add 2 seconds each retry\n            \"interval_max\": 30,  # Max 30 seconds between retries\n        },\n    },\n)\n</code></pre>"},{"location":"connections/#connection-visibility","title":"Connection Visibility","text":"<p>The broker automatically adds hostname to connection properties, making it easy to identify connections in RabbitMQ management UI:</p> <p></p> <p>You can also set a custom connection name:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://...\",\n        \"transport_options\": {\n            \"client_properties\": {\n                \"connection_name\": \"my-app-worker\",  # Custom name\n            },\n        },\n    },\n)\n</code></pre> <p>If not set, uses system hostname automatically.</p>"},{"location":"connections/#ssltls","title":"SSL/TLS","text":"<p>Secure connections:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqps://...\",  # Note: amqps\n        \"ssl\": True,\n        \"ssl_options\": {\n            \"ca_certs\": \"/path/to/ca.pem\",\n            \"certfile\": \"/path/to/client-cert.pem\",\n            \"keyfile\": \"/path/to/client-key.pem\",\n        },\n    },\n)\n</code></pre>"},{"location":"connections/#monitoring","title":"Monitoring","text":"<p>Check connection health:</p> <pre><code>from dramatiq_kombu_broker.testing import ensure_consumer_connection_rabbitmq\n\ntry:\n    ensure_consumer_connection_rabbitmq(broker)\n    print(\"Connection OK\")\nexcept Exception as e:\n    print(f\"Connection failed: {e}\")\n</code></pre> <p>Use in health check endpoints:</p> <pre><code># Flask example\n@app.route('/health')\ndef health():\n    try:\n        ensure_consumer_connection_rabbitmq(broker)\n        return {\"status\": \"healthy\"}, 200\n    except Exception:\n        return {\"status\": \"unhealthy\"}, 503\n</code></pre>"},{"location":"connections/#connection-limits","title":"Connection Limits","text":"<p>RabbitMQ has connection limits. Monitor in management UI or via API:</p> <pre><code># Check connection count\nrabbitmqctl list_connections\n\n# Check limits\nrabbitmqctl environment | grep connection\n</code></pre> <p>Increase limits if needed:</p> <pre><code># rabbitmq.conf\nconnection_max = 1000\n</code></pre>"},{"location":"connections/#troubleshooting","title":"Troubleshooting","text":""},{"location":"connections/#too-many-connections","title":"Too Many Connections","text":"<p>Symptom: <code>connection_limit_reached</code> errors</p> <p>Solutions: - Use <code>ConnectionSharedKombuBroker</code> instead of <code>ConnectionPooledKombuBroker</code> - Reduce <code>max_connections</code> in pool - Increase RabbitMQ connection limit</p>"},{"location":"connections/#connection-refused","title":"Connection Refused","text":"<p>Symptom: <code>ConnectionRefusedError</code></p> <p>Check: - RabbitMQ is running - Firewall allows port 5672 (or 5671 for SSL) - Correct hostname/port in connection string - User has permissions on vhost</p>"},{"location":"connections/#heartbeat-failures","title":"Heartbeat Failures","text":"<p>Symptom: Connections drop unexpectedly</p> <p>Try: - Reduce heartbeat interval (30 instead of 60) - Check network stability - Increase RabbitMQ heartbeat timeout</p>"},{"location":"connections/#channel-errors","title":"Channel Errors","text":"<p>Symptom: <code>ChannelError: 406, PRECONDITION_FAILED</code></p> <p>Usually topology mismatches. See Topologies.</p>"},{"location":"connections/#best-practices","title":"Best Practices","text":"<ol> <li>Use connection pooling for multi-process workers</li> <li>Use shared connection for threaded apps</li> <li>Heartbeats enabled by default (60s) - adjust if needed for your network</li> <li>Configure retries for reliability</li> <li>Monitor connection count in RabbitMQ UI</li> <li>Use SSL in production</li> <li>Set connection names for debugging</li> </ol>"},{"location":"connections/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Full connection options</li> <li>Performance Tuning - Optimize connection usage</li> <li>Troubleshooting - Fix connection issues</li> </ul>"},{"location":"delivery-guarantees/","title":"Delivery Guarantees","text":"<p>When you send a task with <code>task.send()</code>, dramatiq-kombu-broker provides two parameters to control delivery reliability: <code>confirm_delivery</code> and <code>blocking_acknowledge</code>.</p>"},{"location":"delivery-guarantees/#quick-reference","title":"Quick Reference","text":"Parameter Default Stage What It Does <code>confirm_delivery</code> <code>True</code> Publishing RabbitMQ confirms message reached queue <code>confirm_timeout</code> <code>5.0</code> Publishing Timeout for publish confirmation (deadlock protection) <code>blocking_acknowledge</code> <code>True</code> Processing Worker waits for ACK confirmation <code>mandatory</code> <code>True</code> Publishing Reject if queue doesn't exist <p>Recommended for production:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": os.environ[\"RABBITMQ_URL\"],\n        \"transport_options\": {\n            \"confirm_publish\": True,\n        },\n    },\n    confirm_delivery=True,         # Ensure delivery\n    confirm_timeout=5.0,           # Prevent deadlocks (default)\n    blocking_acknowledge=True,     # Ensure processing\n)\n</code></pre>"},{"location":"delivery-guarantees/#confirm_delivery-publishing-guarantees","title":"confirm_delivery: Publishing Guarantees","text":"<p>Default: <code>True</code></p> <p>Controls whether RabbitMQ confirms that published messages were accepted and routed to queues using Publisher Confirms.</p>"},{"location":"delivery-guarantees/#with-confirm_deliverytrue","title":"With confirm_delivery=True","text":"<pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    confirm_delivery=True,  # Default\n)\n\n@dramatiq.actor\ndef send_email(email):\n    ...\n\n# Raises exception if RabbitMQ doesn't confirm\nsend_email.send(\"user@example.com\")\n</code></pre> <p>Guarantees: - Message reached RabbitMQ broker - Message was routed to a queue (via <code>mandatory=True</code>) - Synchronous errors on failure</p> <p>Trade-off: Slightly slower publishing</p>"},{"location":"delivery-guarantees/#with-confirm_deliveryfalse","title":"With confirm_delivery=False","text":"<pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"...\",\n        \"transport_options\": {\n            \"confirm_publish\": False,\n        },\n    },\n    confirm_delivery=False,\n)\n</code></pre> <p>When to use: - Very high throughput (thousands of tasks/second) - Non-critical tasks (logging, analytics) - Can tolerate message loss</p> <p>Risks: - Messages lost on network issues - Messages lost on RabbitMQ restart - No error notification</p>"},{"location":"delivery-guarantees/#confirm_timeout-deadlock-protection","title":"confirm_timeout: Deadlock Protection","text":"<p>Default: <code>5.0</code> seconds</p> <p>When <code>confirm_delivery=True</code>, the broker waits for RabbitMQ to confirm message receipt. If the connection drops during this wait, the thread can block indefinitely - a deadlock. The <code>confirm_timeout</code> parameter prevents this.</p> <p>The Problem:</p> <pre><code>1. Publisher sends message to RabbitMQ\n2. Publisher waits for confirmation...\n3. Connection drops (network issue, RabbitMQ restart, etc.)\n4. Without timeout: Publisher waits FOREVER\n5. Worker thread is stuck, cannot process other work\n</code></pre> <p>The Solution:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    confirm_delivery=True,\n    confirm_timeout=5.0,  # Default: 5 seconds\n)\n</code></pre> <p>After 5 seconds without confirmation, the broker raises an exception instead of blocking forever.</p> <p>How it works with heartbeat:</p> <p>Both <code>confirm_timeout</code> and <code>heartbeat</code> protect against connection issues, but at different levels:</p> Parameter Level Protects Against <code>heartbeat=60</code> Transport Dead connections (no activity for 60s) <code>confirm_timeout=5.0</code> Application Blocked publish confirmation <p>They are complementary: - <code>heartbeat</code> detects dead connections during idle periods - <code>confirm_timeout</code> prevents blocking during active publishing</p> <p>Configuration examples:</p> <pre><code># Production (recommended)\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://user:pass@rabbitmq:5672/\",\n        \"heartbeat\": 60,  # Detect dead connections\n    },\n    confirm_delivery=True,\n    confirm_timeout=5.0,  # Prevent publish deadlocks\n)\n\n# High-latency network\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://user:pass@remote-rabbitmq:5672/\",\n        \"heartbeat\": 60,\n    },\n    confirm_delivery=True,\n    confirm_timeout=30.0,  # More time for slow confirmations\n)\n</code></pre> <p>When timeout triggers:</p> <p>If <code>confirm_timeout</code> expires, an exception is raised. This is the expected behavior - it's better to fail fast than hang forever. The message should be retried by the calling code.</p> <p>See Troubleshooting if you experience timeout issues.</p>"},{"location":"delivery-guarantees/#blocking_acknowledge-processing-guarantees","title":"blocking_acknowledge: Processing Guarantees","text":"<p>Default: <code>True</code></p> <p>Controls when worker sends ACK (acknowledgment) to RabbitMQ after processing a message.</p>"},{"location":"delivery-guarantees/#with-blocking_acknowledgetrue-recommended","title":"With blocking_acknowledge=True (Recommended)","text":"<pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    blocking_acknowledge=True,  # Default\n)\n\n@dramatiq.actor\ndef process_order(order_id):\n    result = heavy_computation(order_id)\n    # Worker sends ACK and WAITS for confirmation\n    # Only then takes next message\n    return result\n</code></pre> <p>Use for: - Financial operations - Critical tasks - Tasks with side effects (emails, database changes) - At-least-once delivery requirements</p> <p>Trade-off: Worker waits for ACK confirmation before next message</p>"},{"location":"delivery-guarantees/#with-blocking_acknowledgefalse","title":"With blocking_acknowledge=False","text":"<pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    blocking_acknowledge=False,\n)\n\n@dramatiq.actor\ndef process_order(order_id):\n    result = heavy_computation(order_id)\n    # Worker queues ACK and IMMEDIATELY takes next message\n    # ACK sent later, asynchronously\n    return result\n</code></pre> <p>Use for: - High-throughput systems - Idempotent tasks (safe to run twice) - Low-priority tasks</p> <p>Risks: - ACK lost on network failure - Message may be processed twice - Errors logged but don't block execution</p>"},{"location":"delivery-guarantees/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"delivery-guarantees/#maximum-reliability-production-default","title":"Maximum Reliability (Production Default)","text":"<pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://user:pass@rabbitmq:5672/\",\n        \"transport_options\": {\n            \"confirm_publish\": True,\n        },\n    },\n    confirm_delivery=True,        # Confirm publishing\n    blocking_acknowledge=True,    # Confirm processing\n)\n</code></pre> <p>Guarantees: At-least-once delivery, all errors raised</p> <p>Trade-off: Slightly lower throughput</p>"},{"location":"delivery-guarantees/#maximum-throughput-non-critical-tasks-only","title":"Maximum Throughput (Non-Critical Tasks Only)","text":"<pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://user:pass@rabbitmq:5672/\",\n        \"transport_options\": {\n            \"confirm_publish\": False,\n        },\n    },\n    confirm_delivery=False,       # Skip confirmation\n    blocking_acknowledge=False,   # Async ACK\n)\n</code></pre> <p>Benefits: Maximum speed, minimal latency</p> <p>Risks: Messages may be lost, tasks may run twice</p>"},{"location":"delivery-guarantees/#hybrid-approach","title":"Hybrid Approach","text":"<p>Use different brokers for different task types:</p> <pre><code># Critical tasks: reliable\nmain_broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    confirm_delivery=True,\n    blocking_acknowledge=True,\n)\n\n# Analytics: fast\nanalytics_broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    confirm_delivery=False,\n    blocking_acknowledge=False,\n)\n\n@dramatiq.actor(broker=main_broker)\ndef charge_payment(amount):\n    ...\n\n@dramatiq.actor(broker=analytics_broker)\ndef track_event(event_type, data):\n    ...\n</code></pre>"},{"location":"delivery-guarantees/#common-issues","title":"Common Issues","text":""},{"location":"delivery-guarantees/#tasks-running-twice","title":"Tasks Running Twice","text":"<p>This is normal with at-least-once delivery. Make tasks idempotent:</p> <pre><code>@dramatiq.actor\ndef process_payment(payment_id):\n    payment = Payment.objects.get(id=payment_id)\n    if payment.status == \"processed\":\n        return  # Already done\n\n    charge_card(payment)\n    payment.status = \"processed\"\n    payment.save()\n</code></pre>"},{"location":"delivery-guarantees/#low-throughput","title":"Low Throughput","text":"<p>If you have thousands of small tasks per second:</p> <p>Option 1: Use <code>blocking_acknowledge=False</code> for idempotent tasks</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={...},\n    confirm_delivery=True,         # Keep for reliability\n    blocking_acknowledge=False,    # Speed up processing\n)\n</code></pre> <p>Option 2: Scale workers instead</p> <pre><code>dramatiq tasks --processes 8 --threads 4\n</code></pre>"},{"location":"delivery-guarantees/#connection-closed-during-ack","title":"Connection Closed During ACK","text":"<p>With blocking_acknowledge=True: - Exception raised immediately - Message stays in queue - Task retried after reconnection</p> <p>With blocking_acknowledge=False: - Error logged - Worker already processing next message - May cause duplicate processing</p> <p>Solution: Use <code>blocking_acknowledge=True</code> for critical tasks and ensure idempotency.</p>"},{"location":"delivery-guarantees/#monitoring","title":"Monitoring","text":"<p>Track delivery failures:</p> <pre><code>from prometheus_client import Counter\n\ndelivery_failures = Counter(\n    'dramatiq_delivery_failures_total',\n    'Failed message deliveries',\n)\n\n@dramatiq.actor\ndef important_task(data):\n    try:\n        result = process(data)\n    except Exception:\n        delivery_failures.inc()\n        raise\n    return result\n</code></pre> <p>Monitor in RabbitMQ Management UI: - Ready - Messages in queue - Unacked - Messages taken but not ACKed - Publish rate - Throughput - Consumer count - Active workers</p>"},{"location":"delivery-guarantees/#memory-and-performance-implications","title":"Memory and Performance Implications","text":""},{"location":"delivery-guarantees/#delayed-messages-and-memory","title":"Delayed Messages and Memory","text":"<p>When Dramatiq sends delayed messages, they stay unacked in RabbitMQ until the delay expires. This creates memory pressure:</p> <ul> <li>Unacked messages accumulate - Each delayed message consumes RAM on the RabbitMQ server</li> <li>Transaction log grows - Quorum queues maintain WAL logs for all unacked messages, consuming disk space</li> <li>Performance degradation - High volumes of long-lived delayed messages impact RabbitMQ performance and can overwhelm consumers</li> <li>Memory exhaustion risk - Very long delays (days/weeks) can trigger memory alarms</li> </ul> <p>This is different from immediate messages, which are acknowledged quickly after processing.</p>"},{"location":"delivery-guarantees/#protection-with-max_delay_time","title":"Protection with max_delay_time","text":"<p>Configure <code>max_delay_time</code> to prevent memory issues from long delays:</p> <pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker, DefaultDramatiqTopology\nimport datetime as dt\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://user:pass@rabbitmq:5672/\",\n        \"transport_options\": {\n            \"confirm_publish\": True,\n        },\n    },\n    topology=DefaultDramatiqTopology(\n        max_delay_time=dt.timedelta(hours=3)  # Fail-fast protection\n    ),\n    confirm_delivery=True,\n    blocking_acknowledge=True,\n)\n</code></pre> <p>How it works:</p> <ol> <li>Application validation - Broker raises <code>DelayTooLongError</code> when delay exceeds limit</li> <li>RabbitMQ failsafe - Queue-level TTL (<code>x-message-ttl</code>) as backup protection</li> <li>Defense in depth - Two layers ensure protection even if one fails</li> </ol>"},{"location":"delivery-guarantees/#monitoring_1","title":"Monitoring","text":"<p>Track rejected messages due to excessive delay:</p> <pre><code>from prometheus_client import Counter\nfrom dramatiq_kombu_broker import DelayTooLongError\n\ndelay_too_long_errors = Counter(\n    'dramatiq_delay_too_long_errors_total',\n    'Messages rejected due to excessive delay',\n    ['queue'],\n)\n\n@dramatiq.actor\ndef process_task(task_id):\n    ...\n\n# When sending with delay\ntry:\n    process_task.send_with_options(args=(123,), delay=delay_ms)\nexcept DelayTooLongError as e:\n    delay_too_long_errors.labels(queue=e.queue_name).inc()\n    logger.error(\n        f\"Rejected task: delay {e.delay}ms exceeds max {e.max_delay}ms\"\n    )\n    raise\n</code></pre> <p>What to monitor:</p> <ul> <li><code>DelayTooLongError</code> exceptions - indicates delays exceeding limits</li> <li>RabbitMQ memory usage - watch for growth with delayed messages</li> <li>Queue depths - monitor <code>*.DQ</code> (delay queue) sizes</li> <li>Unacked message counts - high counts indicate memory pressure</li> </ul>"},{"location":"delivery-guarantees/#recommendations","title":"Recommendations","text":"Scenario max_delay_time Monitoring Notes Critical production 3 hours Alert on <code>DelayTooLongError</code> Conservative limit, prevents memory issues Background jobs 24 hours Log and track trends Suitable for daily tasks Development/testing None Optional No restrictions, easier testing High-volume delayed tasks 1-6 hours Alert + memory monitoring Lower limit for high message volumes <p>Configuration examples:</p> <pre><code># Conservative production setup\ntopology = DefaultDramatiqTopology(\n    max_delay_time=dt.timedelta(hours=3)\n)\n\n# Background job setup\ntopology = DefaultDramatiqTopology(\n    max_delay_time=dt.timedelta(hours=24)\n)\n\n# Development (no limits)\ntopology = DefaultDramatiqTopology()  # max_delay_time=None (default)\n</code></pre>"},{"location":"delivery-guarantees/#when-not-to-use-delayed-messages","title":"When NOT to Use Delayed Messages","text":"<p>Delayed messages are powerful but have limitations. Use alternatives in these cases:</p> Scenario Why Not Delayed Messages Alternative Delays &gt; 24 hours Memory pressure, inefficient Cron jobs, APScheduler, Celery Beat High-precision timing RabbitMQ TTL has ~1s precision Dedicated scheduler, database polling Very high volume delays Memory exhaustion risk Batch processing, time-series database Delays &gt; weeks Extremely inefficient Calendar-based scheduling systems Dynamic rescheduling Messages can't be modified once queued Database-backed task queue <p>Example: Wrong approach</p> <pre><code># DON'T: Use delayed messages for weekly reports\n@dramatiq.actor\ndef send_weekly_report(user_id):\n    ...\n\n# This will hold messages unacked for 7 days!\nsend_weekly_report.send_with_options(\n    args=(user_id,),\n    delay=7*24*60*60*1000  # 7 days in ms\n)\n</code></pre> <p>Example: Right approach</p> <pre><code># DO: Use cron or APScheduler for recurring tasks\nfrom apscheduler.schedulers.blocking import BlockingScheduler\n\nscheduler = BlockingScheduler()\n\n@scheduler.scheduled_job('cron', day_of_week='mon', hour=9)\ndef generate_weekly_reports():\n    for user_id in get_active_users():\n        send_weekly_report.send(user_id)  # Immediate execution\n\nscheduler.start()\n</code></pre>"},{"location":"delivery-guarantees/#performance-trade-offs","title":"Performance Trade-offs","text":"<p>With max_delay_time protection:</p> Aspect Impact Mitigation Publishing Minimal (one int comparison) Negligible performance impact Memory Reduced (prevents long delays) Lower RabbitMQ memory usage Reliability Higher (fail-fast on issues) Better error visibility Queue creation One-time TTL setup No ongoing overhead <p>Without max_delay_time (default):</p> Aspect Impact Risk Publishing Slightly faster (no validation) No protection from excessive delays Memory Can grow unbounded RabbitMQ memory exhaustion Reliability No early error detection Silent failures, debugging harder Operations No limits Requires manual monitoring"},{"location":"delivery-guarantees/#further-reading","title":"Further Reading","text":"<p>Delivery Guarantees: - RabbitMQ Publisher Confirms - Publishing guarantees and acknowledgements - RabbitMQ Consumer Acknowledgements - Processing guarantees - RabbitMQ Reliability Guide - Overall reliability patterns - RabbitMQ Mandatory Flag - Message routing guarantees</p> <p>Memory and Performance: - Quorum Queues - Write-ahead-log (WAL) and memory management - RabbitMQ Best Practices - CloudAMQP - Managing unacked messages - How to Handle High Memory Usage - CloudAMQP - Memory troubleshooting - Key Metrics for RabbitMQ Monitoring - Datadog - Monitoring memory and unacked messages</p> <p>Delayed Messages: - Time-To-Live and Expiration - TTL behavior and limitations - Delayed Messages Documentation - CloudAMQP - Best practices for delayed messages - RabbitMQ Message TTL - Compile N Run - TTL ordering issues</p> <p>Troubleshooting: - 13 Common RabbitMQ Mistakes - CloudAMQP - Common pitfalls - GitHub Issue #1164 - Real-world memory alarm case</p>"},{"location":"examples/","title":"Examples","text":"<p>Real-world usage examples for dramatiq-kombu-broker.</p>"},{"location":"examples/#basic-task-processing","title":"Basic Task Processing","text":"<pre><code>import dramatiq\nfrom dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://guest:guest@localhost:5672/\"\n    }\n)\ndramatiq.set_broker(broker)\n\n@dramatiq.actor\ndef send_welcome_email(user_id: int, email: str):\n    # Send email logic here\n    print(f\"Sending welcome email to {email}\")\n    return True\n\n# Usage\nsend_welcome_email.send(123, \"user@example.com\")\n</code></pre>"},{"location":"examples/#delayed-tasks","title":"Delayed Tasks","text":"<pre><code>@dramatiq.actor\ndef send_reminder(user_id: int):\n    print(f\"Sending reminder to user {user_id}\")\n\n# Send after 1 hour\nsend_reminder.send_with_options(\n    args=(123,),\n    delay=3600000  # 1 hour in milliseconds\n)\n\n# Send tomorrow at 9 AM\nimport datetime\nnow = datetime.datetime.now()\ntomorrow_9am = now.replace(hour=9, minute=0, second=0) + datetime.timedelta(days=1)\ndelay_ms = int((tomorrow_9am - now).total_seconds() * 1000)\n\nsend_reminder.send_with_options(args=(123,), delay=delay_ms)\n</code></pre>"},{"location":"examples/#priority-queue","title":"Priority Queue","text":"<pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    max_priority=10,  # Enable priorities 0-10\n)\ndramatiq.set_broker(broker)\n\n@dramatiq.actor\ndef process_order(order_id: int):\n    print(f\"Processing order {order_id}\")\n\n# Normal priority (0)\nprocess_order.send(100)\n\n# High priority (10)\nprocess_order.send_with_options(args=(200,), broker_priority=10)\n\n# Low priority (1)\nprocess_order.send_with_options(args=(300,), broker_priority=1)\n</code></pre>"},{"location":"examples/#multiple-queues","title":"Multiple Queues","text":"<pre><code>@dramatiq.actor(queue_name=\"critical\")\ndef urgent_task(data):\n    print(f\"Processing urgent: {data}\")\n\n@dramatiq.actor(queue_name=\"background\")\ndef slow_task(data):\n    print(f\"Processing background: {data}\")\n\n# Start workers for specific queues:\n# dramatiq tasks --queues critical\n# dramatiq tasks --queues background\n</code></pre>"},{"location":"examples/#custom-default-queue-name","title":"Custom Default Queue Name","text":"<p>Replace the default queue name for all actors without changing their code:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    default_queue_name=\"myapp\",  # Replace \"default\" with \"myapp\"\n)\ndramatiq.set_broker(broker)\n\n# This actor will use \"myapp\" queue (automatically replaced from \"default\")\n@dramatiq.actor\ndef send_email(to: str, subject: str):\n    print(f\"Sending email to {to}\")\n\n# This actor keeps its explicit \"notifications\" queue (no replacement)\n@dramatiq.actor(queue_name=\"notifications\")\ndef send_push_notification(user_id: int, message: str):\n    print(f\"Push to user {user_id}: {message}\")\n\n# Usage\nsend_email.send(\"user@example.com\", \"Welcome!\")  # Goes to \"myapp\" queue\nsend_push_notification.send(123, \"Hello!\")       # Goes to \"notifications\" queue\n</code></pre> <p>When to use:</p> <ul> <li>Namespace queues by application name in shared RabbitMQ</li> <li>Migrate from another broker that used different queue naming</li> <li>Run multiple environments (dev, staging, prod) on same RabbitMQ</li> </ul> <p>See Configuration for detailed explanation.</p>"},{"location":"examples/#retries-and-error-handling","title":"Retries and Error Handling","text":"<pre><code>@dramatiq.actor(\n    max_retries=3,\n    min_backoff=1000,  # Start with 1 second\n    max_backoff=60000,  # Max 60 seconds\n)\ndef flaky_api_call(url: str):\n    import requests\n    response = requests.get(url, timeout=30)\n    response.raise_for_status()\n    return response.json()\n\n# Will retry up to 3 times with exponential backoff\nflaky_api_call.send(\"https://api.example.com/data\")\n</code></pre>"},{"location":"examples/#django-integration","title":"Django Integration","text":"<pre><code># settings.py\nINSTALLED_APPS = [\n    # ...\n    'django_dramatiq',\n]\n\nDRAMATIQ_BROKER = {\n    \"BROKER\": \"dramatiq_kombu_broker.broker.ConnectionSharedKombuBroker\",\n    \"OPTIONS\": {\n        \"kombu_connection_options\": {\n            \"hostname\": \"amqp://guest:guest@localhost:5672/\",\n        },\n        \"connection_holder_options\": {\n            \"consumer_channel_pool_size\": 5,\n        },\n        \"max_priority\": 10,\n    },\n}\n\n# myapp/tasks.py\nimport dramatiq\n\n@dramatiq.actor\ndef process_user_signup(user_id: int):\n    from myapp.models import User\n    user = User.objects.get(id=user_id)\n    # Send welcome email, create profile, etc.\n\n# myapp/views.py\nfrom myapp.tasks import process_user_signup\n\ndef signup_view(request):\n    user = User.objects.create(...)\n    process_user_signup.send(user.id)\n    return HttpResponse(\"Signup successful!\")\n</code></pre>"},{"location":"examples/#batch-processing","title":"Batch Processing","text":"<pre><code>@dramatiq.actor\ndef process_batch(item_ids: list[int]):\n    for item_id in item_ids:\n        process_item(item_id)\n\n# Send batches\nitems = list(range(1000))\nbatch_size = 100\n\nfor i in range(0, len(items), batch_size):\n    batch = items[i:i + batch_size]\n    process_batch.send(batch)\n</code></pre>"},{"location":"examples/#periodic-tasks","title":"Periodic Tasks","text":"<pre><code># Use APScheduler with Dramatiq\nfrom apscheduler.schedulers.blocking import BlockingScheduler\n\nscheduler = BlockingScheduler()\n\n@dramatiq.actor\ndef daily_report():\n    # Generate and send daily report\n    print(\"Generating daily report...\")\n\n@scheduler.scheduled_job('cron', hour=9, minute=0)\ndef schedule_daily_report():\n    daily_report.send()\n\n# Run scheduler\nscheduler.start()\n</code></pre>"},{"location":"examples/#chain-tasks","title":"Chain Tasks","text":"<pre><code>@dramatiq.actor\ndef download_file(url: str) -&gt; str:\n    # Download and return file path\n    return \"/tmp/downloaded_file.pdf\"\n\n@dramatiq.actor\ndef process_file(file_path: str) -&gt; dict:\n    # Process file and return results\n    return {\"processed\": True, \"path\": file_path}\n\n@dramatiq.actor\ndef send_notification(results: dict):\n    print(f\"Processing complete: {results}\")\n\n# Chain using callbacks\nfrom dramatiq.middleware import Callbacks\n\ndownload_file.send_with_options(\n    args=(\"https://example.com/file.pdf\",),\n    on_success=process_file.message(),\n)\n</code></pre>"},{"location":"examples/#custom-topology","title":"Custom Topology","text":"<pre><code>from dramatiq_kombu_broker import DLXRoutingTopology\nimport datetime as dt\n\n# Route delayed messages through DLX for monitoring\ntopology = DLXRoutingTopology(\n    delay_queue_ttl=dt.timedelta(hours=24),  # Max 24h delay\n    dead_letter_message_ttl=None,  # No TTL on DLX\n)\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    topology=topology,\n)\n</code></pre>"},{"location":"examples/#health-checks","title":"Health Checks","text":"<pre><code>from flask import Flask, jsonify\nfrom dramatiq_kombu_broker.testing import ensure_consumer_connection_rabbitmq\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    try:\n        ensure_consumer_connection_rabbitmq(broker)\n        return jsonify({\"status\": \"healthy\", \"broker\": \"connected\"}), 200\n    except Exception as e:\n        return jsonify({\"status\": \"unhealthy\", \"error\": str(e)}), 503\n</code></pre>"},{"location":"examples/#production-configuration","title":"Production Configuration","text":"<pre><code>import os\nfrom dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": os.environ[\"RABBITMQ_URL\"],\n        \"heartbeat\": 60,  # Default value, shown explicitly for documentation\n        \"ssl\": True,\n        \"ssl_options\": {\n            \"ca_certs\": \"/etc/ssl/certs/ca.pem\",\n        },\n        \"transport_options\": {\n            \"max_retries\": 3,\n            \"interval_start\": 0,\n            \"interval_step\": 2,\n            \"interval_max\": 30,\n            \"confirm_publish\": True,\n        },\n    },\n    connection_holder_options={\n        \"max_connections\": 20,\n    },\n    default_queue_name=\"myapp\",\n    max_priority=10,\n    confirm_delivery=True,\n    max_enqueue_attempts=3,\n    max_declare_attempts=5,\n)\n</code></pre>"},{"location":"examples/#testing","title":"Testing","text":"<pre><code>import pytest\nfrom dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\n@pytest.fixture\ndef test_broker():\n    broker = ConnectionPooledKombuBroker(\n        kombu_connection_options={\n            \"hostname\": \"amqp://guest:guest@localhost:5672/test\"\n        }\n    )\n    yield broker\n    broker.flush_all()  # Clean up\n    broker.close()\n\ndef test_task_processing(test_broker):\n    import dramatiq\n    dramatiq.set_broker(test_broker)\n\n    @dramatiq.actor\n    def add(x, y):\n        return x + y\n\n    add.send(2, 3)\n\n    # Process messages\n    worker = dramatiq.Worker(test_broker, worker_threads=1)\n    worker.start()\n    test_broker.join(add.queue_name, timeout=5000)\n    worker.stop()\n</code></pre>"},{"location":"examples/#monitoring-with-prometheus","title":"Monitoring with Prometheus","text":"<pre><code>from dramatiq.middleware import Prometheus\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    middleware=[\n        Prometheus(http_host=\"0.0.0.0\", http_port=9191),\n        # ... other middleware\n    ],\n)\n\n# Metrics available at http://localhost:9191\n</code></pre>"},{"location":"examples/#error-tracking-with-sentry","title":"Error Tracking with Sentry","text":"<pre><code>from dramatiq.middleware import Callbacks\nimport sentry_sdk\n\nsentry_sdk.init(dsn=\"your-sentry-dsn\")\n\n@dramatiq.actor\ndef task_with_error_tracking(data):\n    try:\n        # Process data\n        pass\n    except Exception as e:\n        sentry_sdk.capture_exception(e)\n        raise\n</code></pre>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>See the tests directory for more examples.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>RabbitMQ 3.7 or higher (recommended: 3.12+)</li> <li>dramatiq &gt;= 1.17.0</li> </ul>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The simplest way to install dramatiq-kombu-broker is via pip:</p> <pre><code>pip install dramatiq-kombu-broker\n</code></pre>"},{"location":"installation/#install-with-django-support","title":"Install with Django Support","text":"<p>If you're using Django with django-dramatiq:</p> <pre><code>pip install dramatiq-kombu-broker django-dramatiq\n</code></pre>"},{"location":"installation/#install-from-source","title":"Install from Source","text":"<p>For development or to get the latest features:</p> <pre><code>git clone https://github.com/spumer/dramatiq-kombu-broker.git\ncd dramatiq-kombu-broker\npip install -e .\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import dramatiq_kombu_broker\nprint(dramatiq_kombu_broker.__version__)\n</code></pre>"},{"location":"installation/#setting-up-rabbitmq","title":"Setting Up RabbitMQ","text":""},{"location":"installation/#using-docker","title":"Using Docker","text":"<p>The quickest way to get RabbitMQ running:</p> <pre><code>docker run -d \\\n  --name rabbitmq \\\n  -p 5672:5672 \\\n  -p 15672:15672 \\\n  -e RABBITMQ_DEFAULT_USER=guest \\\n  -e RABBITMQ_DEFAULT_PASS=guest \\\n  rabbitmq:3.12-management\n</code></pre> <p>Access the management UI at http://localhost:15672 (guest/guest)</p>"},{"location":"installation/#using-docker-compose","title":"Using Docker Compose","text":"<p>Create <code>docker-compose.yml</code>:</p> <pre><code>version: \"3.9\"\n\nservices:\n  rabbitmq:\n    image: rabbitmq:3.12-management\n    ports:\n      - \"5672:5672\"\n      - \"15672:15672\"\n    environment:\n      RABBITMQ_DEFAULT_USER: guest\n      RABBITMQ_DEFAULT_PASS: guest\n    healthcheck:\n      test: rabbitmq-diagnostics -q ping\n      interval: 10s\n      timeout: 5s\n      retries: 5\n</code></pre> <p>Start RabbitMQ:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"installation/#system-package-managers","title":"System Package Managers","text":"Ubuntu/DebianmacOSCentOS/RHEL <pre><code>sudo apt-get install rabbitmq-server\nsudo systemctl enable rabbitmq-server\nsudo systemctl start rabbitmq-server\n</code></pre> <pre><code>brew install rabbitmq\nbrew services start rabbitmq\n</code></pre> <pre><code>sudo yum install rabbitmq-server\nsudo systemctl enable rabbitmq-server\nsudo systemctl start rabbitmq-server\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"installation/#development-tools","title":"Development Tools","text":"<p>For development, install additional dependencies:</p> <pre><code>pip install dramatiq-kombu-broker[dev]\n</code></pre> <p>This includes: - pytest - Testing framework - mypy - Type checking - ruff - Linting and formatting - pre-commit - Git hooks</p>"},{"location":"installation/#connection-pooling","title":"Connection Pooling","text":"<p>Connection pooling is built-in. For thread-safe channel pooling, the required dependency <code>kombu-pyamqp-threadsafe</code> is automatically installed.</p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get started in 5 minutes</li> <li>Configuration - Configure your broker</li> <li>Examples - See usage examples</li> </ul>"},{"location":"messages/","title":"Message Processing","text":"<p>How messages flow through the broker and workers.</p>"},{"location":"messages/#message-lifecycle","title":"Message Lifecycle","text":"<ol> <li>Enqueue - Actor sends message to broker</li> <li>Route - Broker puts message in appropriate queue</li> <li>Consume - Worker pulls message from queue</li> <li>Process - Actor function executes</li> <li>Acknowledge - Worker ACKs or NACKs message</li> </ol>"},{"location":"messages/#sending-messages","title":"Sending Messages","text":""},{"location":"messages/#immediate-send","title":"Immediate Send","text":"<pre><code>@dramatiq.actor\ndef send_email(email: str):\n    pass\n\n# Basic send\nsend_email.send(\"user@example.com\")\n\n# Equivalent to\nsend_email.send_with_options(args=(\"user@example.com\",))\n</code></pre>"},{"location":"messages/#delayed-send","title":"Delayed Send","text":"<pre><code># Delay 5 seconds\nsend_email.send_with_options(\n    args=(\"user@example.com\",),\n    delay=5000  # milliseconds\n)\n</code></pre>"},{"location":"messages/#priority-send","title":"Priority Send","text":"<pre><code># High priority\nsend_email.send_with_options(\n    args=(\"urgent@example.com\",),\n    broker_priority=10\n)\n</code></pre>"},{"location":"messages/#message-format","title":"Message Format","text":"<p>Messages are JSON-serialized by default:</p> <pre><code>{\n  \"queue_name\": \"default\",\n  \"actor_name\": \"send_email\",\n  \"args\": [\"user@example.com\"],\n  \"kwargs\": {},\n  \"options\": {\n    \"eta\": 1234567890,\n    \"broker_priority\": 5\n  },\n  \"message_id\": \"unique-id\",\n  \"message_timestamp\": 1234567890\n}\n</code></pre>"},{"location":"messages/#acknowledgments","title":"Acknowledgments","text":""},{"location":"messages/#auto-ack-default","title":"Auto-ACK (Default)","text":"<p>Worker automatically ACKs after successful processing:</p> <pre><code>@dramatiq.actor\ndef my_task(data):\n    process(data)\n    # Automatically ACKed\n</code></pre>"},{"location":"messages/#manual-ack","title":"Manual ACK","text":"<p>Control acknowledgment in middleware:</p> <pre><code>class ManualAckMiddleware:\n    def after_process_message(self, broker, message, *, result=None, exception=None):\n        if exception:\n            message.nack()  # Reject and requeue\n        else:\n            message.ack()  # Acknowledge\n</code></pre>"},{"location":"messages/#check-ack-status","title":"Check ACK Status","text":"<pre><code>from dramatiq import Message\n\ndef process_message(broker, message: Message):\n    # Do something\n    if message.acknowledged:\n        print(\"Already ACKed\")\n</code></pre>"},{"location":"messages/#message-ttl","title":"Message TTL","text":""},{"location":"messages/#queue-level-ttl","title":"Queue-Level TTL","text":"<p>Set TTL on entire queue (not recommended for work queues):</p> <pre><code># This is set by topology for dead letter queues\ndead_letter_message_ttl = dt.timedelta(days=7)\n</code></pre>"},{"location":"messages/#message-level-ttl","title":"Message-Level TTL","text":"<p>Set TTL per message via <code>expiration</code> property (used for delays):</p> <pre><code># Dramatiq sets this automatically for delays\nchannel.basic_publish(\n    body=message.encode(),\n    properties={\"expiration\": \"5000\"}  # 5 seconds\n)\n</code></pre>"},{"location":"messages/#dead-letter-queue","title":"Dead Letter Queue","text":"<p>Failed messages go to dead letter queue (DLQ):</p> <pre><code># For queue \"tasks\":\n# - tasks       - Main queue\n# - tasks.DQ    - Delay queue\n# - tasks.XQ    - Dead letter queue (failed messages)\n</code></pre>"},{"location":"messages/#inspecting-dlq","title":"Inspecting DLQ","text":"<pre><code>def check_dlq(broker, queue_name):\n    dlq_name = broker.topology.get_dead_letter_queue_name(queue_name)\n    _, count, _ = broker.get_queue_message_counts(queue_name)\n    print(f\"Messages in DLQ: {count}\")\n</code></pre>"},{"location":"messages/#reprocessing-dlq","title":"Reprocessing DLQ","text":"<p>Manually move messages from DLQ back to main queue via RabbitMQ management UI or:</p> <pre><code># Via rabbitmqadmin\nrabbitmqadmin get queue=tasks.XQ requeue=false count=10 | \\\nrabbitmqadmin publish routing_key=tasks\n</code></pre>"},{"location":"messages/#message-persistence","title":"Message Persistence","text":"<p>Messages are persistent by default (<code>delivery_mode=2</code>):</p> <pre><code># In broker.py\nproducer.publish(\n    body=message.encode(),\n    delivery_mode=2,  # Persistent\n)\n</code></pre> <p>This ensures messages survive RabbitMQ restart.</p>"},{"location":"messages/#confirm-delivery","title":"Confirm Delivery","text":"<p>See Delivery Guarantees for how to configure message delivery confirmation.</p>"},{"location":"messages/#message-routing","title":"Message Routing","text":""},{"location":"messages/#standard-flow","title":"Standard Flow","text":"<pre><code>Actor.send() \u2192 Main Queue \u2192 Worker\n</code></pre>"},{"location":"messages/#delayed-flow","title":"Delayed Flow","text":"<pre><code>Actor.send_with_options(delay=X) \u2192 Delay Queue (wait) \u2192 Main Queue \u2192 Worker\n</code></pre>"},{"location":"messages/#failed-message-flow","title":"Failed Message Flow","text":"<pre><code>Worker (exception) \u2192 Dead Letter Queue\n</code></pre>"},{"location":"messages/#queue-depths","title":"Queue Depths","text":"<p>Monitor queue depths:</p> <pre><code>def monitor_queues(broker):\n    for queue_name in broker.get_declared_queues():\n        main, delay, dlq = broker.get_queue_message_counts(queue_name)\n        print(f\"{queue_name}:\")\n        print(f\"  Main: {main}\")\n        print(f\"  Delay: {delay}\")\n        print(f\"  DLQ: {dlq}\")\n</code></pre>"},{"location":"messages/#troubleshooting","title":"Troubleshooting","text":""},{"location":"messages/#messages-not-processing","title":"Messages Not Processing","text":"<p>Check: 1. Worker is running 2. Worker consuming from correct queue 3. No exceptions in worker logs 4. RabbitMQ connection is healthy</p>"},{"location":"messages/#messages-stuck-in-delay-queue","title":"Messages Stuck in Delay Queue","text":"<p>Check: - Delay queue has dead-letter configuration - Dead-letter routing key matches main queue name - Main queue exists</p>"},{"location":"messages/#messages-going-to-dlq","title":"Messages Going to DLQ","text":"<p>Check worker logs for exceptions. Common causes: - Unhandled exceptions - Message deserialization errors - Actor not found</p>"},{"location":"messages/#best-practices","title":"Best Practices","text":"<ol> <li>Use delays sparingly - Don't delay millions of messages</li> <li>Monitor queue depths - Alert on growing queues</li> <li>Check DLQ regularly - Failed messages need attention</li> <li>Set reasonable TTLs - Don't let messages sit forever</li> <li>Enable confirm_delivery - Ensure reliable delivery</li> <li>Handle exceptions - Log errors before they reach DLQ</li> </ol>"},{"location":"messages/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - Message processing examples</li> <li>Troubleshooting - Fix message issues</li> <li>Configuration - Configure message handling</li> </ul>"},{"location":"migration/","title":"Migration Guide","text":"<p>How to migrate from Dramatiq's standard RabbitMQ broker to dramatiq-kombu-broker.</p>"},{"location":"migration/#why-migrate","title":"Why Migrate?","text":"<p>Common reasons:</p> <ul> <li>Hitting connection limits</li> <li>Need better connection pooling</li> <li>Want topology flexibility</li> <li>Getting \"Connection limit reached\" errors</li> <li>Need channel pooling for threaded apps</li> </ul>"},{"location":"migration/#quick-migration","title":"Quick Migration","text":""},{"location":"migration/#1-install","title":"1. Install","text":"<pre><code>pip install dramatiq-kombu-broker\n</code></pre>"},{"location":"migration/#2-update-broker","title":"2. Update Broker","text":"<p>Before: <pre><code>from dramatiq.brokers.rabbitmq import RabbitmqBroker\n\nbroker = RabbitmqBroker(url=\"amqp://guest:guest@localhost:5672/\")\n</code></pre></p> <p>After: <pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://guest:guest@localhost:5672/\"\n    }\n)\n</code></pre></p>"},{"location":"migration/#3-test","title":"3. Test","text":"<p>Run your workers and verify messages process correctly.</p>"},{"location":"migration/#django-migration","title":"Django Migration","text":"<p>Before (django-dramatiq): <pre><code>DRAMATIQ_BROKER = {\n    \"BROKER\": \"dramatiq.brokers.rabbitmq.RabbitmqBroker\",\n    \"OPTIONS\": {\n        \"url\": \"amqp://guest:guest@localhost:5672/\",\n    },\n}\n</code></pre></p> <p>After: <pre><code>DRAMATIQ_BROKER = {\n    \"BROKER\": \"dramatiq_kombu_broker.broker.ConnectionSharedKombuBroker\",\n    \"OPTIONS\": {\n        \"kombu_connection_options\": {\n            \"hostname\": \"amqp://guest:guest@localhost:5672/\",\n        },\n    },\n}\n</code></pre></p>"},{"location":"migration/#parameter-mapping","title":"Parameter Mapping","text":""},{"location":"migration/#connection-url","title":"Connection URL","text":"<p>Standard broker: <pre><code>broker = RabbitmqBroker(url=\"amqp://user:pass@host:5672/vhost\")\n</code></pre></p> <p>Kombu broker: <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://user:pass@host:5672/vhost\"\n    }\n)\n</code></pre></p>"},{"location":"migration/#connection-parameters","title":"Connection Parameters","text":"<p>Standard broker: <pre><code>broker = RabbitmqBroker(\n    host=\"localhost\",\n    port=5672,\n    credentials=pika.PlainCredentials(\"guest\", \"guest\"),\n    heartbeat=60,\n)\n</code></pre></p> <p>Kombu broker: <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"localhost\",\n        \"port\": 5672,\n        \"userid\": \"guest\",\n        \"password\": \"guest\",\n        \"heartbeat\": 60,\n    }\n)\n</code></pre></p> <p>Note: Starting from version 0.3.0 with default heartbeat, <code>heartbeat=60</code> is set automatically. You only need to specify it if you want a different value.</p>"},{"location":"migration/#max-priority","title":"Max Priority","text":"<p>Standard broker: <pre><code>broker = RabbitmqBroker(url=\"...\", max_priority=10)\n</code></pre></p> <p>Kombu broker: <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"...\"},\n    max_priority=10,\n)\n</code></pre></p>"},{"location":"migration/#queue-name-migration","title":"Queue Name Migration","text":"<p>If your old setup used a different default queue name (e.g., <code>\"dramatiq\"</code> instead of <code>\"default\"</code>), you can migrate without changing actor code:</p> <p>Before (actors with explicit queue names): <pre><code># You had to specify queue_name on every actor\n@dramatiq.actor(queue_name=\"dramatiq\")\ndef task_one():\n    pass\n\n@dramatiq.actor(queue_name=\"dramatiq\")\ndef task_two():\n    pass\n</code></pre></p> <p>After (using default_queue_name): <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"...\"},\n    default_queue_name=\"dramatiq\",  # Replace \"default\" with \"dramatiq\"\n)\ndramatiq.set_broker(broker)\n\n# No need to specify queue_name anymore - it's automatic\n@dramatiq.actor\ndef task_one():\n    pass\n\n@dramatiq.actor\ndef task_two():\n    pass\n\n# Actors with explicit non-default queues still work as expected\n@dramatiq.actor(queue_name=\"critical\")\ndef urgent_task():\n    pass\n</code></pre></p> <p>This approach:</p> <ul> <li>Removes boilerplate from actor definitions</li> <li>Centralizes queue naming in broker configuration</li> <li>Makes it easier to change queue names across all actors</li> </ul> <p>See Configuration for detailed explanation.</p>"},{"location":"migration/#common-issues","title":"Common Issues","text":""},{"location":"migration/#issue-topology-precondition-failed","title":"Issue: Topology Precondition Failed","text":"<p>Error: <pre><code>amqp.exceptions.PreconditionFailed: inequivalent arg 'x-dead-letter-exchange'\n</code></pre></p> <p>Cause: Delay queues have different arguments between brokers.</p> <p>Solution 1 - Clean slate: <pre><code># Delete existing queues via RabbitMQ management UI\n# Or use rabbitmqctl:\nrabbitmqctl delete_queue myqueue.DQ\nrabbitmqctl delete_queue myqueue\nrabbitmqctl delete_queue myqueue.XQ\n</code></pre></p> <p>Solution 2 - Let broker handle it:</p> <p>The broker sets <code>ignore_different_topology=True</code> by default, which logs warnings but continues. This works if you're not changing queue structure.</p>"},{"location":"migration/#issue-connection-pools","title":"Issue: Connection Pools","text":"<p>Standard broker doesn't have real connection pooling. After migrating:</p> <ol> <li>Monitor connection count in RabbitMQ UI</li> <li>Adjust <code>max_connections</code> if needed</li> <li>For Django, use <code>ConnectionSharedKombuBroker</code> instead</li> </ol>"},{"location":"migration/#zero-downtime-migration","title":"Zero-Downtime Migration","text":"<p>For production with no downtime:</p>"},{"location":"migration/#step-1-run-both-brokers","title":"Step 1: Run Both Brokers","text":"<p>Deploy new code that can use both brokers:</p> <pre><code># config.py\nUSE_NEW_BROKER = os.getenv(\"USE_NEW_BROKER\", \"false\") == \"true\"\n\nif USE_NEW_BROKER:\n    broker = ConnectionPooledKombuBroker(...)\nelse:\n    broker = RabbitmqBroker(...)\n</code></pre>"},{"location":"migration/#step-2-test-new-broker","title":"Step 2: Test New Broker","text":"<p>Start one worker with new broker:</p> <pre><code>USE_NEW_BROKER=true dramatiq tasks\n</code></pre> <p>Monitor for errors. Leave it running for a while.</p>"},{"location":"migration/#step-3-gradual-rollout","title":"Step 3: Gradual Rollout","text":"<p>Slowly increase workers using new broker:</p> <pre><code># Old broker workers\ndramatiq tasks &amp;\ndramatiq tasks &amp;\n\n# New broker workers\nUSE_NEW_BROKER=true dramatiq tasks &amp;\n</code></pre>"},{"location":"migration/#step-4-clean-up-queues","title":"Step 4: Clean Up Queues","text":"<p>Once all workers use new broker and queues are empty:</p> <pre><code># Delete old delay queues if topology changed\nrabbitmqctl delete_queue myqueue.DQ\n</code></pre>"},{"location":"migration/#step-5-remove-old-broker","title":"Step 5: Remove Old Broker","text":"<p>After a week with no issues, remove old broker code.</p>"},{"location":"migration/#testing-migration","title":"Testing Migration","text":"<p>Before production:</p> <pre><code># test_migration.py\nimport dramatiq\nfrom dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://guest:guest@localhost:5672/test\"  # test vhost\n    }\n)\ndramatiq.set_broker(broker)\n\n@dramatiq.actor\ndef test_task(x):\n    return x * 2\n\n# Test immediate send\ntest_task.send(5)\n\n# Test delayed send\ntest_task.send_with_options(args=(10,), delay=5000)\n\n# Run worker\n# dramatiq test_migration\n</code></pre>"},{"location":"migration/#rollback-plan","title":"Rollback Plan","text":"<p>If issues occur:</p> <ol> <li>Stop new broker workers</li> <li>Revert code to old broker</li> <li>Start old broker workers</li> <li>Messages in queue will process normally</li> </ol> <p>The queue structure is compatible, so rollback is safe.</p>"},{"location":"migration/#feature-comparison","title":"Feature Comparison","text":"Feature Standard Broker Kombu Broker Connection pooling Limited Yes Channel pooling No Yes (SharedKombuBroker) Topology mismatch handling Fails Configurable Delayed messages Works Works Priority queues Yes Yes Middleware Same Same Message format Same Same"},{"location":"migration/#next-steps","title":"Next Steps","text":"<p>After migration:</p> <ol> <li>Monitor connection count</li> <li>Check queue depths</li> <li>Verify delayed messages work</li> <li>Test retry logic</li> <li>Update monitoring dashboards</li> </ol>"},{"location":"migration/#getting-help","title":"Getting Help","text":"<p>If you hit issues:</p> <ol> <li>Check Troubleshooting</li> <li>Enable debug logging: <code>PYTHONUNBUFFERED=1 dramatiq tasks --verbose</code></li> <li>Ask on GitHub Discussions</li> <li>Report bugs on GitHub Issues</li> </ol>"},{"location":"performance/","title":"Performance Tuning","text":"<p>Optimize dramatiq-kombu-broker for your workload.</p>"},{"location":"performance/#connection-pooling","title":"Connection Pooling","text":""},{"location":"performance/#pooled-broker","title":"Pooled Broker","text":"<p>Best for multiple worker processes:</p> <pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    connection_holder_options={\n        \"max_connections\": 20,  # Tune based on worker count\n    },\n)\n</code></pre> <p>Rule of thumb: <code>max_connections = number of worker processes \u00d7 2</code></p>"},{"location":"performance/#shared-broker","title":"Shared Broker","text":"<p>Best for threaded applications:</p> <pre><code>from dramatiq_kombu_broker import ConnectionSharedKombuBroker\n\nbroker = ConnectionSharedKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    connection_holder_options={\n        \"consumer_channel_pool_size\": 10,  # Tune based on thread count\n    },\n)\n</code></pre> <p>Rule of thumb: <code>channel_pool_size = number of threads / 2</code></p>"},{"location":"performance/#worker-configuration","title":"Worker Configuration","text":""},{"location":"performance/#thread-count","title":"Thread Count","text":"<pre><code># CPU-bound tasks\ndramatiq tasks --threads $(nproc)\n\n# I/O-bound tasks\ndramatiq tasks --threads $(($(nproc) * 2))\n\n# High-concurrency\ndramatiq tasks --threads 20\n</code></pre>"},{"location":"performance/#prefetch-count","title":"Prefetch Count","text":"<p>How many messages worker pulls at once:</p> <pre><code># Low prefetch (fairness, better for slow tasks)\ndramatiq tasks --prefetch 1\n\n# High prefetch (throughput, better for fast tasks)\ndramatiq tasks --prefetch 10\n</code></pre> <p>Trade-off: - Low prefetch: Better load balancing, lower throughput - High prefetch: Higher throughput, worse load balancing</p>"},{"location":"performance/#message-processing","title":"Message Processing","text":""},{"location":"performance/#batch-operations","title":"Batch Operations","text":"<p>Before (slow): <pre><code>@dramatiq.actor\ndef process_item(item_id):\n    item = db.get(item_id)\n    item.process()\n    db.save(item)\n\n# Sends 1000 messages\nfor item_id in range(1000):\n    process_item.send(item_id)\n</code></pre></p> <p>After (fast): <pre><code>@dramatiq.actor\ndef process_batch(item_ids):\n    items = db.get_many(item_ids)  # Single query\n    for item in items:\n        item.process()\n    db.save_many(items)  # Single query\n\n# Sends 10 messages\nbatch_size = 100\nfor i in range(0, 1000, batch_size):\n    process_batch.send(list(range(i, i + batch_size)))\n</code></pre></p>"},{"location":"performance/#async-io","title":"Async I/O","text":"<p>For I/O-bound tasks, use async:</p> <pre><code>import asyncio\nimport dramatiq\n\n@dramatiq.actor\ndef fetch_urls(urls):\n    asyncio.run(fetch_all(urls))\n\nasync def fetch_all(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_one(session, url) for url in urls]\n        return await asyncio.gather(*tasks)\n</code></pre>"},{"location":"performance/#rabbitmq-configuration","title":"RabbitMQ Configuration","text":""},{"location":"performance/#queue-arguments","title":"Queue Arguments","text":"<p>Limit queue size:</p> <pre><code>@dataclasses.dataclass\nclass LimitedTopology(DefaultDramatiqTopology):\n    def _get_canonical_queue_arguments(self, queue_name, dlx=True):\n        args = super()._get_canonical_queue_arguments(queue_name, dlx)\n        args[\"x-max-length\"] = 10000  # Max 10k messages\n        args[\"x-overflow\"] = \"reject-publish\"  # Reject when full\n        return args\n</code></pre>"},{"location":"performance/#message-ttl","title":"Message TTL","text":"<p>Don't let messages sit forever:</p> <pre><code>topology = DefaultDramatiqTopology(\n    dead_letter_message_ttl=dt.timedelta(days=3),  # DLQ messages expire after 3 days\n)\n</code></pre>"},{"location":"performance/#network-optimization","title":"Network Optimization","text":""},{"location":"performance/#heartbeat","title":"Heartbeat","text":"<p>Heartbeat is set to 60 seconds by default. Adjust only if needed:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://...\",\n        \"heartbeat\": 30,  # Override default (60s) for unstable networks\n    },\n)\n</code></pre> <ul> <li>Lower (30s): Better for unstable networks</li> <li>Higher (120s): Less overhead, use if network is stable</li> </ul>"},{"location":"performance/#confirm-delivery","title":"Confirm Delivery","text":"<pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    confirm_delivery=True,  # Reliability vs speed trade-off\n)\n</code></pre> <ul> <li><code>True</code>: Slower, but guarantees delivery</li> <li><code>False</code>: Faster, but may lose messages on broker restart</li> </ul>"},{"location":"performance/#monitoring","title":"Monitoring","text":""},{"location":"performance/#queue-depths","title":"Queue Depths","text":"<pre><code>def monitor(broker):\n    for queue in broker.get_declared_queues():\n        main, delay, dlq = broker.get_queue_message_counts(queue)\n        if main &gt; 1000:\n            alert(f\"Queue {queue} backlog: {main}\")\n</code></pre>"},{"location":"performance/#connection-count","title":"Connection Count","text":"<p>Check RabbitMQ management UI or:</p> <pre><code>rabbitmqctl list_connections | wc -l\n</code></pre>"},{"location":"performance/#memory-usage","title":"Memory Usage","text":"<pre><code># Worker memory\nps aux | grep dramatiq\n\n# RabbitMQ memory\nrabbitmqctl status | grep memory\n</code></pre>"},{"location":"performance/#benchmarking","title":"Benchmarking","text":""},{"location":"performance/#simple-benchmark","title":"Simple Benchmark","text":"<pre><code>import time\nimport dramatiq\n\n@dramatiq.actor\ndef noop():\n    pass\n\nstart = time.time()\nfor _ in range(10000):\n    noop.send()\nduration = time.time() - start\n\nprint(f\"Enqueued {10000/duration:.0f} messages/sec\")\n</code></pre>"},{"location":"performance/#load-testing","title":"Load Testing","text":"<pre><code># Start multiple workers\nfor i in {1..10}; do\n    dramatiq tasks --threads 5 &amp;\ndone\n\n# Send messages\npython benchmark.py\n\n# Monitor\nwatch -n 1 'rabbitmqctl list_queues name messages'\n</code></pre>"},{"location":"performance/#optimization-checklist","title":"Optimization Checklist","text":"<p>Connection: - \u2705 Use appropriate broker type (Pooled vs Shared) - \u2705 Tune pool/channel sizes - \u2705 Enable confirm_delivery for important messages</p> <p>Workers: - \u2705 Match thread count to workload type - \u2705 Tune prefetch based on task duration - \u2705 Run multiple worker processes for CPU-bound tasks</p> <p>Code: - \u2705 Batch database operations - \u2705 Use async for I/O-bound tasks - \u2705 Profile slow actors - \u2705 Cache expensive computations</p> <p>Queues: - \u2705 Set max queue length to prevent memory issues - \u2705 Use priority queues strategically - \u2705 Monitor queue depths</p> <p>RabbitMQ: - \u2705 Use fast disks (SSD) for persistent messages - \u2705 Increase memory limit if needed - \u2705 Enable lazy queues for large backlogs</p>"},{"location":"performance/#common-bottlenecks","title":"Common Bottlenecks","text":""},{"location":"performance/#database","title":"Database","text":"<p>Problem: N+1 queries</p> <p>Solution: Batch operations, eager loading</p>"},{"location":"performance/#external-apis","title":"External APIs","text":"<p>Problem: Blocking I/O</p> <p>Solution: Use async, connection pooling</p>"},{"location":"performance/#cpu","title":"CPU","text":"<p>Problem: CPU-intensive tasks</p> <p>Solution: More worker processes, multiprocessing</p>"},{"location":"performance/#memory","title":"Memory","text":"<p>Problem: Large messages, memory leaks</p> <p>Solution: Process in chunks, profile memory usage</p>"},{"location":"performance/#production-tips","title":"Production Tips","text":"<ol> <li>Start small, scale up - Begin with default settings, measure, then optimize</li> <li>Monitor everything - Queue depths, worker memory, RabbitMQ stats</li> <li>Test under load - Simulate production traffic in staging</li> <li>Use separate queues - Critical vs background tasks</li> <li>Set timeouts - Don't let tasks run forever</li> <li>Graceful degradation - Handle overload scenarios</li> </ol>"},{"location":"performance/#next-steps","title":"Next Steps","text":"<ul> <li>Monitoring - Set up Prometheus</li> <li>Troubleshooting - Fix performance issues</li> <li>Configuration - All tuning options</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get up and running with dramatiq-kombu-broker in 5 minutes!</p>"},{"location":"quickstart/#basic-setup","title":"Basic Setup","text":""},{"location":"quickstart/#1-install-the-package","title":"1. Install the Package","text":"<pre><code>pip install dramatiq-kombu-broker\n</code></pre>"},{"location":"quickstart/#2-create-your-first-actor","title":"2. Create Your First Actor","text":"<p>Create a file <code>tasks.py</code>:</p> <pre><code>import dramatiq\nfrom dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\n# Configure the broker\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://guest:guest@localhost:5672/\"\n    }\n)\n\n# Set as the default broker\ndramatiq.set_broker(broker)\n\n# Define an actor\n@dramatiq.actor\ndef send_email(email: str, subject: str, body: str):\n    print(f\"Sending email to {email}: {subject}\")\n    # Your email sending logic here\n    return True\n</code></pre>"},{"location":"quickstart/#3-start-a-worker","title":"3. Start a Worker","text":"<p>In your terminal:</p> <pre><code>dramatiq tasks\n</code></pre> <p>You should see:</p> <pre><code>[INFO] Dramatiq '1.17.0' is booting up.\n[INFO] Discovered actors:\n[INFO]   - send_email\n[INFO] Worker process is ready for action.\n</code></pre>"},{"location":"quickstart/#4-send-tasks","title":"4. Send Tasks","text":"<p>In Python REPL or another script:</p> <pre><code>from tasks import send_email\n\n# Send immediately\nsend_email.send(\"user@example.com\", \"Hello\", \"Welcome!\")\n\n# Send with delay (5 seconds)\nsend_email.send_with_options(\n    args=(\"user@example.com\", \"Hello\", \"Welcome!\"),\n    delay=5000  # milliseconds\n)\n\n# Send with priority\nsend_email.send_with_options(\n    args=(\"urgent@example.com\", \"URGENT\", \"Alert!\"),\n    broker_priority=10\n)\n</code></pre>"},{"location":"quickstart/#django-integration","title":"Django Integration","text":""},{"location":"quickstart/#1-install-django-dramatiq","title":"1. Install Django Dramatiq","text":"<pre><code>pip install dramatiq-kombu-broker django-dramatiq\n</code></pre>"},{"location":"quickstart/#2-configure-django-settings","title":"2. Configure Django Settings","text":"<p>In <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    'django_dramatiq',\n]\n\nDRAMATIQ_BROKER = {\n    \"BROKER\": \"dramatiq_kombu_broker.broker.ConnectionSharedKombuBroker\",\n    \"OPTIONS\": {\n        \"kombu_connection_options\": {\n            \"hostname\": \"amqp://guest:guest@localhost:5672/\",\n        },\n        \"max_priority\": 10,\n    },\n}\n\n# Optional: Configure middleware\nDRAMATIQ_BROKER[\"OPTIONS\"][\"middleware\"] = [\n    \"dramatiq.middleware.Prometheus\",\n    \"dramatiq.middleware.AgeLimit\",\n    \"dramatiq.middleware.TimeLimit\",\n    \"dramatiq.middleware.Callbacks\",\n    \"dramatiq.middleware.Retries\",\n    \"django_dramatiq.middleware.DbConnectionsMiddleware\",\n]\n</code></pre>"},{"location":"quickstart/#3-create-tasks","title":"3. Create Tasks","text":"<p>Create <code>myapp/tasks.py</code>:</p> <pre><code>import dramatiq\n\n@dramatiq.actor\ndef process_order(order_id: int):\n    from myapp.models import Order\n    order = Order.objects.get(id=order_id)\n    order.process()\n    return True\n</code></pre>"},{"location":"quickstart/#4-run-worker","title":"4. Run Worker","text":"<pre><code>python manage.py rundramatiq\n</code></pre>"},{"location":"quickstart/#5-enqueue-tasks","title":"5. Enqueue Tasks","text":"<p>In your Django views or management commands:</p> <pre><code>from myapp.tasks import process_order\n\n# In a view\ndef create_order(request):\n    order = Order.objects.create(user=request.user)\n    process_order.send(order.id)\n    return redirect('order_success')\n</code></pre>"},{"location":"quickstart/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"quickstart/#connection-pooling","title":"Connection Pooling","text":"<p>For high-throughput applications:</p> <pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://guest:guest@localhost:5672/\",\n        # heartbeat=60 is set by default, no need to specify\n        \"ssl\": False,\n    },\n    connection_holder_options={\n        \"max_connections\": 10,  # Connection pool size\n    },\n    max_priority=10,\n    confirm_delivery=True,  # Ensure messages are delivered\n)\n</code></pre>"},{"location":"quickstart/#thread-safe-shared-connection","title":"Thread-Safe Shared Connection","text":"<p>For applications with many threads:</p> <pre><code>from dramatiq_kombu_broker import ConnectionSharedKombuBroker\n\nbroker = ConnectionSharedKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://guest:guest@localhost:5672/\",\n    },\n    connection_holder_options={\n        \"consumer_channel_pool_size\": 5,  # Channel pool size\n    },\n)\n</code></pre>"},{"location":"quickstart/#custom-queue-name","title":"Custom Queue Name","text":"<p>Change the default queue from \"default\" to something else without modifying actor code:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    default_queue_name=\"myapp\",  # Instead of \"default\"\n)\n\n# This actor will use \"myapp\" queue (replacement happens automatically)\n@dramatiq.actor\ndef my_task():\n    pass\n\n# This actor keeps its explicit queue \"critical\" (no replacement)\n@dramatiq.actor(queue_name=\"critical\")\ndef urgent_task():\n    pass\n</code></pre> <p>See Configuration for detailed explanation.</p>"},{"location":"quickstart/#message-delays","title":"Message Delays","text":"<p>Dramatiq supports delayed message delivery:</p> <pre><code>@dramatiq.actor\ndef send_reminder(user_id: int):\n    print(f\"Reminder for user {user_id}\")\n\n# Send after 1 hour\nsend_reminder.send_with_options(\n    args=(123,),\n    delay=3600000  # 1 hour in milliseconds\n)\n\n# Send after 5 minutes\nsend_reminder.send_with_options(\n    args=(456,),\n    delay=300000  # 5 minutes\n)\n</code></pre>"},{"location":"quickstart/#health-checks","title":"Health Checks","text":"<p>Check if your broker connection is healthy:</p> <pre><code>from dramatiq_kombu_broker.testing import ensure_consumer_connection_rabbitmq\n\n# In your health check endpoint\ntry:\n    ensure_consumer_connection_rabbitmq(broker)\n    return {\"status\": \"healthy\"}\nexcept Exception as e:\n    return {\"status\": \"unhealthy\", \"error\": str(e)}\n</code></pre>"},{"location":"quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/#retry-configuration","title":"Retry Configuration","text":"<pre><code>@dramatiq.actor(max_retries=3, min_backoff=1000, max_backoff=60000)\ndef flaky_task(data):\n    # This will retry up to 3 times with exponential backoff\n    api_call(data)\n</code></pre>"},{"location":"quickstart/#time-limits","title":"Time Limits","text":"<pre><code>@dramatiq.actor(time_limit=30000)  # 30 seconds\ndef long_running_task():\n    # Task will be cancelled if it runs longer than 30 seconds\n    process_data()\n</code></pre>"},{"location":"quickstart/#multiple-queues","title":"Multiple Queues","text":"<pre><code>@dramatiq.actor(queue_name=\"high_priority\")\ndef urgent_task():\n    pass\n\n@dramatiq.actor(queue_name=\"low_priority\")\ndef background_task():\n    pass\n\n# Start workers for specific queues\n# dramatiq tasks --queues high_priority\n# dramatiq tasks --queues low_priority\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Deep dive into all configuration options</li> <li>Topologies - Learn about queue routing strategies</li> <li>Examples - More real-world examples</li> <li>Migration Guide - Migrate from standard dramatiq broker</li> </ul>"},{"location":"topologies/","title":"Queue Topologies","text":"<p>Topologies define how queues are structured and how messages flow between them.</p>"},{"location":"topologies/#overview","title":"Overview","text":"<p>When Dramatiq sends a delayed message, it goes to a \"delay queue\" first. After the delay expires, the message needs to get to the main queue where workers pick it up. The topology controls this routing.</p>"},{"location":"topologies/#default-topology","title":"Default Topology","text":"<p>The standard topology (<code>DefaultDramatiqTopology</code>) works like the regular Dramatiq broker:</p> <pre><code>Message \u2192 Delay Queue (waits) \u2192 Main Queue \u2192 Worker\n</code></pre> <p>When a message's TTL expires in the delay queue, RabbitMQ's dead-letter mechanism routes it directly to the main queue.</p>"},{"location":"topologies/#usage","title":"Usage","text":"<pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\n# Default topology is used automatically\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"}\n)\n</code></pre>"},{"location":"topologies/#queue-structure","title":"Queue Structure","text":"<p>For a queue named \"tasks\":</p> <ul> <li><code>tasks</code> - Main queue where workers consume</li> <li><code>tasks.DQ</code> - Delay queue for delayed messages</li> <li><code>tasks.XQ</code> - Dead letter queue for failed messages</li> </ul>"},{"location":"topologies/#dlx-routing-topology","title":"DLX Routing Topology","text":"<p>Alternative topology that routes expired delay messages to the dead letter queue:</p> <pre><code>Message \u2192 Delay Queue (waits) \u2192 Dead Letter Queue (stops here)\n</code></pre> <p>Messages remain in the dead letter queue and are not automatically forwarded to the main queue. This gives you full control over what happens to delayed messages after they expire.</p>"},{"location":"topologies/#when-to-use","title":"When To Use","text":"<p>Use <code>DLXRoutingTopology</code> if you need to:</p> <ul> <li>Monitor all delayed messages as they expire</li> <li>Add custom processing before messages reach workers</li> <li>Maintain an audit trail of delayed message transitions</li> </ul>"},{"location":"topologies/#usage_1","title":"Usage","text":"<pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker, DLXRoutingTopology\nimport datetime as dt\n\ntopology = DLXRoutingTopology(\n    max_delay_time=dt.timedelta(hours=24),  # Max delay: 24 hours\n    dead_letter_message_ttl=None,  # No TTL on DLX\n)\n\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    topology=topology,\n)\n</code></pre>"},{"location":"topologies/#configuration","title":"Configuration","text":"<pre><code>DLXRoutingTopology(\n    # Maximum delay time for messages (optional)\n    max_delay_time=dt.timedelta(hours=3),\n\n    # TTL for messages in dead letter queue (optional)\n    dead_letter_message_ttl=None,\n\n    # Queue durability\n    durable=True,\n\n    # Auto-delete queues when unused\n    auto_delete=False,\n\n    # Max priority for priority queues\n    max_priority=None,\n)\n</code></pre>"},{"location":"topologies/#managing-long-lived-delayed-messages","title":"Managing Long-Lived Delayed Messages","text":""},{"location":"topologies/#the-problem","title":"The Problem","text":"<p>Dramatiq uses worker-side delayed messages - messages stay unacked in RabbitMQ until their delay expires. When workers consume messages with <code>delay</code>, they hold them in memory without acknowledging. This creates issues:</p> <ul> <li>Memory exhaustion - Long delays (days/weeks) accumulate unacked messages in RAM, potentially triggering memory alarms</li> <li>Transaction log growth - Quorum queues maintain WAL (write-ahead-log) for unacked messages, consuming disk space until messages are acknowledged</li> <li>Performance degradation - High volumes of delayed messages impact RabbitMQ performance and can overwhelm consumers</li> </ul>"},{"location":"topologies/#the-solution-defense-in-depth","title":"The Solution: Defense in Depth","text":"<p>The <code>max_delay_time</code> feature provides two-layer protection:</p> <p>Layer 1: Application Validation - Fail-fast at publishing time. When you try to enqueue a message with <code>delay</code> exceeding <code>max_delay_time</code>, the broker raises <code>DelayTooLongError</code> immediately.</p> <p>Layer 2: RabbitMQ Failsafe - Queue-level TTL (<code>x-message-ttl</code>) as backup. Even if validation is bypassed, RabbitMQ automatically expires messages after the configured TTL.</p>"},{"location":"topologies/#usage-examples","title":"Usage Examples","text":""},{"location":"topologies/#conservative-limit-3-hours","title":"Conservative Limit (3 hours)","text":"<pre><code>from dramatiq_kombu_broker import ConnectionPooledKombuBroker, DefaultDramatiqTopology\nimport datetime as dt\n\ntopology = DefaultDramatiqTopology(\n    max_delay_time=dt.timedelta(hours=3)  # Conservative limit\n)\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    topology=topology,\n)\n\n# This works - 2 hour delay\ntask.send_with_options(delay=2*60*60*1000)  # 2 hours in ms\n\n# This raises DelayTooLongError - exceeds limit\ntask.send_with_options(delay=5*60*60*1000)  # 5 hours in ms\n</code></pre>"},{"location":"topologies/#moderate-limit-24-hours","title":"Moderate Limit (24 hours)","text":"<pre><code>topology = DefaultDramatiqTopology(\n    max_delay_time=dt.timedelta(hours=24)  # Moderate limit for background jobs\n)\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    topology=topology,\n)\n</code></pre>"},{"location":"topologies/#unlimited-backward-compatible","title":"Unlimited (Backward Compatible)","text":"<pre><code>topology = DefaultDramatiqTopology()  # max_delay_time=None (default)\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    topology=topology,\n)\n# No limit - same as before\n</code></pre>"},{"location":"topologies/#exception-handling","title":"Exception Handling","text":"<pre><code>from dramatiq_kombu_broker import DelayTooLongError\n\ntry:\n    task.send_with_options(delay=7*24*60*60*1000)  # 1 week\nexcept DelayTooLongError as e:\n    logger.error(\n        f\"Delay {e.delay}ms exceeds max {e.max_delay}ms for queue {e.queue_name}\"\n    )\n    # Handle: reduce delay, reject request, or queue differently\n</code></pre>"},{"location":"topologies/#dlxroutingtopology-configuration","title":"DLXRoutingTopology Configuration","text":"<p>Use <code>max_delay_time</code> to configure the maximum delay for <code>DLXRoutingTopology</code>:</p> <pre><code>from dramatiq_kombu_broker import DLXRoutingTopology\n\ntopology = DLXRoutingTopology(\n    max_delay_time=dt.timedelta(hours=5),  # Recommended approach\n)\n# Actual limit: 5 hours\n</code></pre> <p>Deprecated: delay_queue_ttl</p> <p>The <code>delay_queue_ttl</code> parameter is deprecated and will be removed in a future version. Use <code>max_delay_time</code> instead.</p> <p>For backward compatibility, if both parameters are provided, <code>delay_queue_ttl</code> takes precedence:</p> <pre><code># Legacy code (deprecated - migrate to max_delay_time)\ntopology = DLXRoutingTopology(\n    delay_queue_ttl=dt.timedelta(hours=1),   # Deprecated, but takes precedence\n    max_delay_time=dt.timedelta(hours=5),    # Ignored when delay_queue_ttl is set\n)\n# Actual limit: 1 hour\n</code></pre>"},{"location":"topologies/#migration-guide","title":"Migration Guide","text":"<p>Existing Applications:</p> <ul> <li>Default: <code>max_delay_time=None</code> - no changes needed</li> <li>Existing queues continue working without modification</li> <li>No queue deletion required</li> </ul> <p>To Enable Protection:</p> <ol> <li> <p>Update topology configuration: <pre><code>topology = DefaultDramatiqTopology(max_delay_time=dt.timedelta(hours=3))\n</code></pre></p> </li> <li> <p>Test in staging first - verify your delays fit within the limit</p> </li> <li> <p>Deploy with new configuration:</p> </li> <li>New queues created with TTL automatically</li> <li> <p>Existing queues continue working (no TTL enforcement until recreated)</p> </li> <li> <p>Optional: Recreate existing delay queues to apply TTL:</p> </li> <li>Stop workers</li> <li>Delete delay queues via RabbitMQ management UI (<code>*.DQ</code> queues)</li> <li>Restart workers (queues recreated with TTL)</li> </ol> <p>Note: If you try to redeclare queues with different TTL, RabbitMQ raises <code>PreconditionFailed</code>. Either delete the queue first or use <code>ignore_different_topology=True</code> (not recommended for production).</p>"},{"location":"topologies/#best-practices","title":"Best Practices","text":"Delay Range Recommended max_delay_time Rationale Minutes to hours 3-6 hours Safe for most use cases, prevents memory issues Hours to days 24 hours Suitable for background jobs and daily tasks Days to weeks Not recommended Use cron jobs or scheduled task systems instead Unlimited <code>None</code> (default) Only if you understand the memory risks <p>Key Recommendations:</p> <ul> <li>Start conservative - Use 3-6 hours initially, increase if needed</li> <li>Monitor delays - Track <code>DelayTooLongError</code> exceptions to identify patterns</li> <li>Use alternatives for long delays - Cron jobs or schedulers for delays &gt; 24 hours</li> <li>Make tasks idempotent - Messages may be processed twice if TTL expires before delivery</li> <li>Test limits in staging - Verify your actual delay patterns before production</li> </ul>"},{"location":"topologies/#further-reading","title":"Further Reading","text":"<p>Official RabbitMQ Documentation:</p> <ul> <li>Consumer Acknowledgements and Publisher Confirms - How unacked messages affect memory</li> <li>Quorum Queues - Write-ahead-log (WAL) and message acknowledgment</li> <li>Time-To-Live and Expiration - TTL behavior and ordering considerations</li> </ul> <p>Best Practices and Troubleshooting:</p> <ul> <li>RabbitMQ Best Practices - CloudAMQP - Memory management with unacked messages</li> <li>Delayed Messages Documentation - CloudAMQP - Implementing delayed messages correctly</li> <li>13 Common RabbitMQ Mistakes - Avoiding common pitfalls</li> <li>Key Metrics for RabbitMQ Monitoring - Datadog - Monitoring unacked messages and queue depth</li> </ul> <p>Real-World Issues:</p> <ul> <li>GitHub Issue #1164 - Memory alarm with many unacked messages</li> </ul>"},{"location":"topologies/#comparison","title":"Comparison","text":"Aspect DefaultDramatiqTopology DLXRoutingTopology Delay routing Direct to main queue To DLX (stops there) Message hops 2 (delay \u2192 main) 2 (delay \u2192 DLX) Final destination Main queue (auto) DLX (manual processing required) Monitoring Limited Full visibility in DLX Use case Standard workflows Audit/monitoring/custom pipelines"},{"location":"topologies/#advanced-custom-topologies","title":"Advanced: Custom Topologies","text":""},{"location":"topologies/#when-to-create-custom-topologies","title":"When to Create Custom Topologies","text":"<p>Default topology works for most cases. Create custom topology when you need:</p> <ul> <li>Different routing strategies</li> <li>Custom queue arguments</li> <li>Environment-specific configurations</li> <li>Special monitoring requirements</li> </ul>"},{"location":"topologies/#basic-example","title":"Basic Example","text":"<pre><code>import dataclasses\nfrom dramatiq_kombu_broker.topology import DefaultDramatiqTopology\n\n@dataclasses.dataclass\nclass MyTopology(DefaultDramatiqTopology):\n    def _get_delay_queue_arguments(self, queue_name: str) -&gt; dict:\n        \"\"\"Customize delay queue.\"\"\"\n        args = super()._get_delay_queue_arguments(queue_name)\n        args[\"x-max-length\"] = 5000  # Limit to 5000 messages\n        return args\n</code></pre> <p>Use it:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    topology=MyTopology(),\n)\n</code></pre>"},{"location":"topologies/#queue-arguments","title":"Queue Arguments","text":"<p>Each topology method returns queue arguments dict that gets passed to RabbitMQ. Common arguments:</p>"},{"location":"topologies/#dead-letter-configuration","title":"Dead Letter Configuration","text":"<pre><code>{\n    \"x-dead-letter-exchange\": \"\",  # Default exchange\n    \"x-dead-letter-routing-key\": \"tasks\",  # Target queue\n}\n</code></pre>"},{"location":"topologies/#ttl-configuration","title":"TTL Configuration","text":"<pre><code>{\n    \"x-message-ttl\": 60000,  # 60 seconds in milliseconds\n}\n</code></pre>"},{"location":"topologies/#priority-configuration","title":"Priority Configuration","text":"<pre><code>{\n    \"x-max-priority\": 10,  # Priorities 0-10\n}\n</code></pre>"},{"location":"topologies/#queue-length-limits","title":"Queue Length Limits","text":"<pre><code>{\n    \"x-max-length\": 1000,  # Max 1000 messages\n    \"x-overflow\": \"reject-publish\",  # Reject new messages when full\n}\n</code></pre>"},{"location":"topologies/#override-methods","title":"Override Methods","text":""},{"location":"topologies/#_get_canonical_queue_arguments","title":"_get_canonical_queue_arguments","text":"<p>Main work queue configuration:</p> <pre><code>def _get_canonical_queue_arguments(self, queue_name: str, dlx: bool = True) -&gt; dict:\n    args = super()._get_canonical_queue_arguments(queue_name, dlx)\n\n    if queue_name == \"critical\":\n        args[\"x-max-priority\"] = 255  # Higher priority range\n\n    return args\n</code></pre>"},{"location":"topologies/#_get_delay_queue_arguments","title":"_get_delay_queue_arguments","text":"<p>Delay queue configuration:</p> <pre><code>def _get_delay_queue_arguments(self, queue_name: str) -&gt; dict:\n    args = super()._get_delay_queue_arguments(queue_name)\n    args[\"x-message-ttl\"] = 86400000  # 24 hours max\n    return args\n</code></pre>"},{"location":"topologies/#_get_dead_letter_queue_arguments","title":"_get_dead_letter_queue_arguments","text":"<p>Dead letter queue configuration:</p> <pre><code>def _get_dead_letter_queue_arguments(self, queue_name: str) -&gt; dict:\n    args = super()._get_dead_letter_queue_arguments(queue_name)\n    args[\"x-max-length\"] = 1000  # Limit DLQ size\n    return args\n</code></pre>"},{"location":"topologies/#migration-between-topologies","title":"Migration Between Topologies","text":"<p>Warning: Changing topologies requires restarting workers and may cause issues with existing messages.</p> <p>Steps to migrate:</p> <ol> <li>Stop all workers</li> <li>Process or purge existing messages</li> <li>Update broker configuration with new topology</li> <li>Restart workers</li> </ol> <p>RabbitMQ will reject the new topology if it conflicts with existing queues. Options:</p> <ul> <li>Delete queues manually via RabbitMQ management UI</li> <li>Use different queue names</li> <li>Set <code>ignore_different_topology=True</code> in broker (not recommended for production)</li> </ul>"},{"location":"topologies/#real-world-examples","title":"Real-World Examples","text":""},{"location":"topologies/#queue-size-limits","title":"Queue Size Limits","text":"<p>Limit queue size using x-max-length:</p> <pre><code>@dataclasses.dataclass\nclass LimitedTopology(DefaultDramatiqTopology):\n    max_queue_length: int = 10000\n    overflow_behavior: str = \"reject-publish\"  # or \"drop-head\"\n\n    def _get_canonical_queue_arguments(self, queue_name: str, dlx: bool = True) -&gt; dict:\n        args = super()._get_canonical_queue_arguments(queue_name, dlx)\n        args[\"x-max-length\"] = self.max_queue_length\n        args[\"x-overflow\"] = self.overflow_behavior\n        return args\n\ntopology = LimitedTopology(max_queue_length=5000)\n</code></pre>"},{"location":"topologies/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>@dataclasses.dataclass\nclass EnvironmentTopology(DefaultDramatiqTopology):\n    environment: str = \"production\"\n\n    @property\n    def dlx_exchange_name(self):\n        return f\"dlx.{self.environment}\"\n\n    def _get_canonical_queue_arguments(self, queue_name: str, dlx: bool = True) -&gt; dict:\n        args = super()._get_canonical_queue_arguments(queue_name, dlx)\n\n        if self.environment == \"development\":\n            args[\"x-message-ttl\"] = 3600000  # 1 hour in dev\n\n        return args\n\ntopology = EnvironmentTopology(environment=\"staging\")\n</code></pre>"},{"location":"topologies/#per-queue-configuration","title":"Per-Queue Configuration","text":"<pre><code>@dataclasses.dataclass\nclass PerQueueTopology(DefaultDramatiqTopology):\n    queue_configs: dict = dataclasses.field(default_factory=dict)\n\n    def _get_canonical_queue_arguments(self, queue_name: str, dlx: bool = True) -&gt; dict:\n        args = super()._get_canonical_queue_arguments(queue_name, dlx)\n        config = self.queue_configs.get(queue_name, {})\n\n        if \"max_length\" in config:\n            args[\"x-max-length\"] = config[\"max_length\"]\n        if \"max_priority\" in config:\n            args[\"x-max-priority\"] = config[\"max_priority\"]\n\n        return args\n\n# Usage\ntopology = PerQueueTopology(\n    queue_configs={\n        \"critical\": {\"max_priority\": 255, \"max_length\": 1000},\n        \"background\": {\"max_length\": 50000},\n    }\n)\n</code></pre>"},{"location":"topologies/#monitoring-topology","title":"Monitoring Topology","text":"<p>Difference from DLXRoutingTopology</p> <p>Unlike <code>DLXRoutingTopology</code> which stops messages in DLX, this custom topology automatically forwards messages from DLX to the canonical queue using <code>x-dead-letter-routing-key</code> on the DLX queue itself.</p> <p>Routes everything through DLX for monitoring, then forwards to canonical queue:</p> <pre><code>@dataclasses.dataclass\nclass MonitoringTopology(DefaultDramatiqTopology):\n    def _get_delay_queue_arguments(self, queue_name: str) -&gt; dict:\n        \"\"\"Route through DLX for visibility.\"\"\"\n        canonical = self.get_canonical_queue_name(queue_name)\n        dlx_name = self.get_dead_letter_queue_name(canonical)\n\n        return {\n            \"x-dead-letter-exchange\": self.dlx_exchange_name,\n            \"x-dead-letter-routing-key\": dlx_name,  # To DLX first\n        }\n\n    def _get_dead_letter_queue_arguments(self, queue_name: str) -&gt; dict:\n        \"\"\"DLX forwards to canonical queue.\"\"\"\n        canonical = self.get_canonical_queue_name(queue_name)\n\n        return {\n            \"x-dead-letter-exchange\": self.dlx_exchange_name,\n            \"x-dead-letter-routing-key\": canonical,  # Then to canonical\n        }\n</code></pre>"},{"location":"topologies/#testing-custom-topologies","title":"Testing Custom Topologies","text":"<pre><code>def test_custom_topology():\n    topology = MyTopology()\n\n    # Test queue arguments\n    args = topology._get_canonical_queue_arguments(\"test\")\n    assert \"x-dead-letter-exchange\" in args\n\n    # Test queue names\n    names = topology.get_queue_name_tuple(\"test\")\n    assert names.canonical == \"test\"\n    assert names.delayed == \"test.DQ\"\n    assert names.dead_letter == \"test.XQ\"\n</code></pre>"},{"location":"topologies/#best-practices_1","title":"Best Practices","text":"<ol> <li>Start with defaults - Only override what you need</li> <li>Test topology changes - Always test in staging first</li> <li>Document custom logic - Add docstrings explaining why you're customizing</li> <li>Keep it simple - Complex routing is hard to debug</li> <li>Don't modify the topology object - Pass a configured instance to the broker</li> <li>Monitor queue depths - Watch for messages stuck in delay or DLX queues</li> </ol>"},{"location":"topologies/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"topologies/#forgetting-dead-letter-parameters","title":"Forgetting Dead Letter Parameters","text":"<pre><code># WRONG - delay queue without dead-letter\ndef _get_delay_queue_arguments(self, queue_name: str) -&gt; dict:\n    return {}  # Messages will never leave delay queue!\n\n# RIGHT - include dead-letter routing\ndef _get_delay_queue_arguments(self, queue_name: str) -&gt; dict:\n    return super()._get_delay_queue_arguments(queue_name)\n</code></pre>"},{"location":"topologies/#circular-routing","title":"Circular Routing","text":"<pre><code># WRONG - creates loop\ndef _get_delay_queue_arguments(self, queue_name: str) -&gt; dict:\n    delay_name = self.get_delay_queue_name(queue_name)\n    return {\n        \"x-dead-letter-routing-key\": delay_name,  # Routes to itself!\n    }\n</code></pre>"},{"location":"topologies/#modifying-topology-after-creation","title":"Modifying Topology After Creation","text":"<pre><code># WRONG - broker should not modify topology\nbroker = ConnectionPooledKombuBroker(topology=my_topology, ...)\nmy_topology.max_priority = 10  # Don't do this!\n\n# RIGHT - configure topology before passing to broker\nmy_topology = MyTopology(max_priority=10)\nbroker = ConnectionPooledKombuBroker(topology=my_topology, ...)\n</code></pre>"},{"location":"topologies/#troubleshooting","title":"Troubleshooting","text":""},{"location":"topologies/#preconditionfailed-error","title":"PreconditionFailed Error","text":"<pre><code>amqp.exceptions.PreconditionFailed: inequivalent arg 'x-dead-letter-exchange'\n</code></pre> <p>This means queue arguments don't match. Either:</p> <ul> <li>Delete the queue and let it recreate</li> <li>Use the same arguments as before</li> <li>Change the queue name</li> </ul>"},{"location":"topologies/#messages-not-routing","title":"Messages Not Routing","text":"<p>Check RabbitMQ logs and management UI:</p> <ol> <li>Verify dead-letter exchange is correct (usually empty string)</li> <li>Check dead-letter routing key matches target queue name</li> <li>Ensure target queue exists before messages expire</li> </ol>"},{"location":"topologies/#delayed-messages-not-working","title":"Delayed Messages Not Working","text":"<p>Common issues:</p> <ul> <li>Delay queue missing dead-letter parameters (use <code>DefaultDramatiqTopology</code>)</li> <li>TTL not set correctly on messages</li> <li>Wrong routing key in dead-letter configuration</li> </ul>"},{"location":"topologies/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Configure topology parameter</li> <li>Migration Guide - Migrate from standard broker</li> <li>Examples - Real-world topology examples</li> <li>API Reference - Topology API details</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and how to fix them.</p>"},{"location":"troubleshooting/#connection-issues","title":"Connection Issues","text":""},{"location":"troubleshooting/#connection-refused","title":"Connection Refused","text":"<p>Error: <code>ConnectionRefusedError: [Errno 111] Connection refused</code></p> <p>Causes: - RabbitMQ not running - Wrong hostname/port - Firewall blocking connection</p> <p>Fix: <pre><code># Check RabbitMQ is running\nsystemctl status rabbitmq-server\n\n# Check port is open\ntelnet localhost 5672\n\n# Check connection string\nbroker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://guest:guest@localhost:5672/\"  # Verify this\n    }\n)\n</code></pre></p>"},{"location":"troubleshooting/#connection-limit-reached","title":"Connection Limit Reached","text":"<p>Error: <code>connection_limit_reached</code></p> <p>Fix 1 - Use Shared Connection: <pre><code># Instead of ConnectionPooledKombuBroker\nfrom dramatiq_kombu_broker import ConnectionSharedKombuBroker\n\nbroker = ConnectionSharedKombuBroker(...)\n</code></pre></p> <p>Fix 2 - Reduce Pool Size: <pre><code>broker = ConnectionPooledKombuBroker(\n    connection_holder_options={\n        \"max_connections\": 5,  # Lower than default\n    }\n)\n</code></pre></p> <p>Fix 3 - Increase RabbitMQ Limit: <pre><code># In rabbitmq.conf\nconnection_max = 1000\n</code></pre></p>"},{"location":"troubleshooting/#heartbeat-failures","title":"Heartbeat Failures","text":"<p>Error: Connection drops unexpectedly</p> <p>By default, heartbeat is set to 60 seconds. To reduce it for unreliable networks:</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://...\",\n        \"heartbeat\": 30,  # Lower than default 60s\n    }\n)\n</code></pre>"},{"location":"troubleshooting/#publish-deadlocks","title":"Publish Deadlocks","text":"<p>Symptoms: - Worker threads hang indefinitely - Message publishing never completes - Application becomes unresponsive during RabbitMQ issues</p> <p>Cause: When <code>confirm_delivery=True</code>, the broker waits for RabbitMQ to confirm message receipt. If the connection drops during this wait (before heartbeat detects it), the thread can block forever.</p> <p>Solution: Use <code>confirm_timeout</code> (enabled by default):</p> <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\n        \"hostname\": \"amqp://...\",\n        \"heartbeat\": 60,  # Transport-level protection\n    },\n    confirm_delivery=True,\n    confirm_timeout=5.0,  # Application-level protection (default)\n)\n</code></pre> <p>If you're getting timeout errors:</p> <ol> <li> <p>Check network latency - High-latency networks may need longer timeout:    <pre><code>confirm_timeout=30.0  # For slow networks\n</code></pre></p> </li> <li> <p>Check RabbitMQ load - Overloaded RabbitMQ may delay confirmations. Monitor RabbitMQ metrics.</p> </li> <li> <p>Check connection stability - Frequent timeouts indicate connection issues. Investigate network or RabbitMQ health.</p> </li> </ol> <p>Relationship with heartbeat:</p> Parameter Purpose When It Helps <code>heartbeat=60</code> Detects dead connections Idle connections, no activity <code>confirm_timeout=5.0</code> Prevents publish blocking Active publishing, connection drops mid-publish <p>Both parameters work together to provide comprehensive connection protection.</p> <p>See Delivery Guarantees for more details.</p>"},{"location":"troubleshooting/#queue-issues","title":"Queue Issues","text":""},{"location":"troubleshooting/#precondition-failed","title":"Precondition Failed","text":"<p>Error: <code>amqp.exceptions.PreconditionFailed: inequivalent arg 'x-dead-letter-exchange'</code></p> <p>Cause: Queue already exists with different arguments</p> <p>Fix: Delete queue and recreate <pre><code># Via rabbitmqctl\nrabbitmqctl delete_queue myqueue\nrabbitmqctl delete_queue myqueue.DQ\nrabbitmqctl delete_queue myqueue.XQ\n\n# Or via management UI\n# Queues tab \u2192 Select queue \u2192 Delete\n</code></pre></p>"},{"location":"troubleshooting/#delayed-messages-not-working","title":"Delayed Messages Not Working","text":"<p>Symptoms: - Messages sent with delay never appear - Delay queue has messages stuck</p> <p>Check 1 - Delay Queue Configuration: <pre><code># Ensure using DefaultDramatiqTopology (not custom)\nfrom dramatiq_kombu_broker import ConnectionPooledKombuBroker\n\nbroker = ConnectionPooledKombuBroker(...)  # Uses DefaultDramatiqTopology\n</code></pre></p> <p>Check 2 - Dead Letter Parameters: <pre><code># Check delay queue has x-dead-letter-routing-key\nrabbitmqctl list_queues name arguments | grep \".DQ\"\n</code></pre></p> <p>Should show: <pre><code>myqueue.DQ  [{&lt;&lt;\"x-dead-letter-routing-key\"&gt;&gt;,&lt;&lt;\"myqueue\"&gt;&gt;}...]\n</code></pre></p> <p>Fix: Delete delay queue, let it recreate with correct parameters</p>"},{"location":"troubleshooting/#messages-going-to-wrong-queue","title":"Messages Going to Wrong Queue","text":"<p>Check routing key: <pre><code>def debug_message(broker, message):\n    print(f\"Queue: {message.queue_name}\")\n    print(f\"Routing key: {message.options.get('routing_key')}\")\n</code></pre></p>"},{"location":"troubleshooting/#worker-issues","title":"Worker Issues","text":""},{"location":"troubleshooting/#worker-not-processing","title":"Worker Not Processing","text":"<p>Check 1 - Worker Running: <pre><code>ps aux | grep dramatiq\n</code></pre></p> <p>Check 2 - Correct Queue: <pre><code>dramatiq tasks --queues myqueue  # Specify queue\n</code></pre></p> <p>Check 3 - Actor Discovered: <pre><code>dramatiq tasks --verbose  # Shows discovered actors\n</code></pre></p>"},{"location":"troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Causes: - Too many worker threads - Memory leaks in actors - Large messages</p> <p>Fix 1 - Reduce Threads: <pre><code>dramatiq tasks --threads 2  # Default: CPU count\n</code></pre></p> <p>Fix 2 - Process Messages in Batches: <pre><code>@dramatiq.actor\ndef process_large_dataset(chunk_ids):\n    for chunk_id in chunk_ids:\n        process_chunk(chunk_id)\n        # Free memory between chunks\n        del chunk_data\n</code></pre></p>"},{"location":"troubleshooting/#slow-processing","title":"Slow Processing","text":"<p>Profile actor: <pre><code>import cProfile\n\n@dramatiq.actor\ndef slow_task(data):\n    profiler = cProfile.Profile()\n    profiler.enable()\n\n    # Your code\n    process(data)\n\n    profiler.disable()\n    profiler.print_stats()\n</code></pre></p> <p>Check: - Database queries (N+1 problem) - External API calls - CPU-intensive operations</p>"},{"location":"troubleshooting/#message-issues","title":"Message Issues","text":""},{"location":"troubleshooting/#messages-lost","title":"Messages Lost","text":"<p>Check 1 - Confirm Delivery: <pre><code>broker = ConnectionPooledKombuBroker(\n    kombu_connection_options={\"hostname\": \"amqp://...\"},\n    confirm_delivery=True,  # Ensure this is True\n)\n</code></pre></p> <p>Check 2 - Message Persistence: Messages are persistent by default. Check RabbitMQ logs for crashes during publishing.</p> <p>Check 3 - Dead Letter Queue: <pre><code>def check_dlq(broker, queue_name):\n    main, delay, dlq = broker.get_queue_message_counts(queue_name)\n    print(f\"DLQ has {dlq} messages\")\n</code></pre></p>"},{"location":"troubleshooting/#messages-stuck-in-dlq","title":"Messages Stuck in DLQ","text":"<p>View DLQ messages: <pre><code># Via rabbitmqadmin\nrabbitmqadmin get queue=myqueue.XQ count=10\n</code></pre></p> <p>Reprocess: <pre><code># Move back to main queue\nrabbitmqadmin get queue=myqueue.XQ requeue=false count=1 | \\\nrabbitmqadmin publish routing_key=myqueue\n</code></pre></p>"},{"location":"troubleshooting/#deserialization-errors","title":"Deserialization Errors","text":"<p>Error: <code>JSONDecodeError</code> or similar</p> <p>Causes: - Message format changed - Corrupted message</p> <p>Fix: <pre><code>@dramatiq.actor\ndef my_task(data):\n    try:\n        process(data)\n    except (ValueError, TypeError) as e:\n        # Log and skip bad message\n        logger.error(f\"Bad message: {e}\")\n        return  # Don't raise, let it ACK\n</code></pre></p>"},{"location":"troubleshooting/#django-issues","title":"Django Issues","text":""},{"location":"troubleshooting/#django-db-connection-errors","title":"Django DB Connection Errors","text":"<p>Error: <code>OperationalError: server closed the connection</code></p> <p>Fix - Use DB Middleware: <pre><code>DRAMATIQ_BROKER[\"OPTIONS\"][\"middleware\"] = [\n    \"django_dramatiq.middleware.DbConnectionsMiddleware\",\n    # ... other middleware\n]\n</code></pre></p>"},{"location":"troubleshooting/#app-not-found","title":"App Not Found","text":"<p>Error: <code>django.core.exceptions.AppRegistryNotReady</code></p> <p>Fix - Ensure Django Setup: <pre><code># tasks.py\nimport django\ndjango.setup()\n\nimport dramatiq\n</code></pre></p>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#high-latency","title":"High Latency","text":"<p>Check 1 - Connection Pool: <pre><code># Increase pool size\nconnection_holder_options={\"max_connections\": 20}\n</code></pre></p> <p>Check 2 - Worker Threads: <pre><code>dramatiq tasks --threads 10  # More threads\n</code></pre></p> <p>Check 3 - Prefetch: <pre><code>dramatiq tasks --prefetch 10  # Default: 1\n</code></pre></p>"},{"location":"troubleshooting/#queue-backlog","title":"Queue Backlog","text":"<p>Symptoms: Messages piling up</p> <p>Fix 1 - More Workers: <pre><code># Start multiple worker processes\nfor i in {1..5}; do\n    dramatiq tasks &amp;\ndone\n</code></pre></p> <p>Fix 2 - Optimize Actors: - Remove unnecessary work - Batch operations - Use asyncio for I/O-bound tasks</p>"},{"location":"troubleshooting/#debugging","title":"Debugging","text":""},{"location":"troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>PYTHONUNBUFFERED=1 dramatiq tasks --verbose\n</code></pre>"},{"location":"troubleshooting/#python-debugging","title":"Python Debugging","text":"<pre><code>@dramatiq.actor\ndef debug_task(data):\n    import pdb; pdb.set_trace()  # Breakpoint\n    process(data)\n</code></pre>"},{"location":"troubleshooting/#rabbitmq-management-ui","title":"RabbitMQ Management UI","text":"<p>Access at <code>http://localhost:15672</code> (guest/guest)</p> <ul> <li>View queue depths</li> <li>Inspect messages</li> <li>Check connection count</li> <li>Monitor memory usage</li> </ul>"},{"location":"troubleshooting/#connection-info","title":"Connection Info","text":"<pre><code>def debug_connections(broker):\n    with broker.connection_holder.acquire_consumer_channel() as channel:\n        print(f\"Connection: {channel.connection}\")\n        print(f\"Is open: {channel.connection.connected}\")\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still stuck:</p> <ol> <li>Check logs - Worker logs, RabbitMQ logs</li> <li>Minimal reproducer - Isolate the problem</li> <li>Search issues - GitHub Issues</li> <li>Ask for help - GitHub Discussions</li> </ol> <p>When asking for help, include: - dramatiq-kombu-broker version - RabbitMQ version - Python version - Full error message and traceback - Minimal code to reproduce</p>"},{"location":"troubleshooting/#common-solutions-summary","title":"Common Solutions Summary","text":"Issue Quick Fix Connection refused Check RabbitMQ is running Connection limit Use ConnectionSharedKombuBroker Publish deadlock Use <code>confirm_timeout=5.0</code> (default) Precondition failed Delete queue, let it recreate Delays not working Delete .DQ queue, use DefaultDramatiqTopology High memory Reduce worker threads Slow processing Profile code, optimize Messages lost Enable confirm_delivery Queue backlog More workers, optimize actors"},{"location":"troubleshooting/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Tune settings</li> <li>Performance - Optimize performance</li> <li>Examples - See working code</li> </ul>"}]}